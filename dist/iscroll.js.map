{"version":3,"sources":["webpack:///iscroll.js","webpack:///webpack/bootstrap c723a952dadaa99f52da","webpack:///./iscroll.js","webpack:///./mixins/EventEmitter.js","webpack:///./mixins/EventProcessor.js","webpack:///./libs/fps.js","webpack:///./components/RenderLayer.js","webpack:///./libs/easings.js","webpack:///./iscroll.options.js","webpack:///./iscroll.detects.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","_EventEmitter","_EventEmitter2","_EventProcessor","_EventProcessor2","_RenderLayer","_RenderLayer2","globalState","LOOP","POINTS","Iscroll","element","options","arguments","undefined","this","window","iscroll","jquery","document","querySelector","container","assign","state","apply","firstElementChild","refresh","ready","emit","value","width","offsetWidth","height","offsetHeight","destructor","off","extend","type","_customEvents","slice","attach","cb","_this","_typeof","types","split","forEach","push","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","keys","Symbol","iterator","next","done","err","attachOnce","callback","detach","filter","item","on","context","_events","addEventListener","eventArr","removeEventListener","splice","constructor","_fps","EVENT_TYPE","pointer","start","move","end","cancel","MSPointer","touch","mouse","listOfInternalEvents","EventHandlingModule","handleEvent","e","eventType","_eventStart","_eventMove","_eventEnd","transitionEnd","_eventTransitionEnd","_eventResize","preventDefault","events","targetTouches","x","y","l","identifier","pageX","pageY","phase","initiated","startX","startY","deltaX","deltaY","startTime","Date","now","currentTime","_renderLoop","changedTouches","_updatePoint","_resizeTimeout","setTimeout","bind","point","xd","yd","distance","Math","sqrt","distanceX","distanceY","theta","atan2","PI","pointCount","read","assignEventsFromOptions","IscrollInstance","eventName","detectTransitionEnd","_ref","detects","","webkit","Moz","O","ms","vendor","hasPointerEvents","hasMSpointerEvents","useTouchEvents","IscrollPrototype","vendors","request","requestAnimationFrame","cancelAnimationFrame","lastTime","readers","writers","currTime","getTime","timeToCall","max","clearTimeout","fn","write","throttle","raf","args","loop","t","_easings","RenderLayer","name","parent","init","subscribe","timeCapsule","timeCapsuleSize","currentX","offsetLeft","currentY","offsetTop","isAnimated","lastX","lastY","time","shift","renderPosition","calculateVelocity","releaseVelocity","parentState","result","transform","styles","overscrollX","getOverscrollX","overscrollY","getOverscrollY","scrollX","allowOverscroll","overscrollReducer","scrollY","style","left","top","firstPoint","lastPoint","xOffset","yOffset","timeOffset","timePerPoint","velocityX","velocityY","speedThreshold","framesX","framesY","framesDefault","_animate","abs","ceil","log","friction","pow","frames","_this2","easing","currentFrame","inertia","tick","direction","results","processInteraction","unsubscribe","b","d","onReady","detectVendorPrefix","elementStyle","createElement","substr","prefixCSSProperty","charAt","toUpperCase","detectPointerEvents","navigator","pointerEnabled","msPointerEnabled","test","userAgent","useMouseEvents","transitionDuration"],"mappings":"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","file":"iscroll.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * iScroll by Matteo \"Cubiq\" Spinelli ~ http://cubiq.org ~ Released under MIT license\n\t */\n\t'use strict';\n\t\n\t// example of debug tool. All debug code will strip on production\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _EventEmitter = __webpack_require__(1);\n\t\n\tvar _EventEmitter2 = _interopRequireDefault(_EventEmitter);\n\t\n\tvar _EventProcessor = __webpack_require__(2);\n\t\n\tvar _EventProcessor2 = _interopRequireDefault(_EventProcessor);\n\t\n\tvar _RenderLayer = __webpack_require__(4);\n\t\n\tvar _RenderLayer2 = _interopRequireDefault(_RenderLayer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tif (false) {\n\t  var _debug = require('./dev/debug.js')('iscroll:iscroll.js');\n\t  window.debug.enable('iscroll:*');\n\t}\n\t\n\t/**\n\t * global Object, with\n\t * @type {Object}\n\t */\n\tvar globalState = {\n\t  LOOP: false,\n\t  POINTS: []\n\t};\n\t\n\t/**\n\t * IScroll\n\t * Main sandbox\n\t * @class\n\t */\n\t\n\tvar Iscroll = function () {\n\t\n\t  /**\n\t   * Constructor\n\t   * @param  {(HTMLElement|string\\jQueryElement)} el - The initiator element\n\t   * @param  {Object} [options]\n\t   */\n\t\n\t  function Iscroll(element) {\n\t    var _this = this;\n\t\n\t    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    _classCallCheck(this, Iscroll);\n\t\n\t\n\t    window.iscroll = this;\n\t\n\t    if (element.jquery) {\n\t      element = element[0];\n\t    }\n\t    if (typeof element === 'string') {\n\t      element = document.querySelector(element);\n\t    }\n\t    if (!element) {\n\t      throw 'Element is not defined!';\n\t    }\n\t\n\t    this.container = element;\n\t    this.options = Object.assign({}, __webpack_require__(6), options);\n\t    this.state = {};\n\t    this.globalState = globalState;\n\t\n\t    // EXTENDS\n\t    __webpack_require__(7).default(this); // can be moved out of constructor, due perfomance reasons\n\t    _EventEmitter2.default.apply(this);\n\t    _EventProcessor2.default.apply(this);\n\t\n\t    // RENDERING\n\t    new _RenderLayer2.default('viewLayer', this.container.firstElementChild, this);\n\t\n\t    this.refresh();\n\t    this.state.ready = true;\n\t\n\t    this.emit('onReady');\n\t\n\t    // #DEV - ADDITIONAL MODULES\n\t    if (false) {\n\t      require('./dev/StatePanel.js').default(this); // State display panel\n\t    }\n\t\n\t    // #DEV - HOT MODULE REPLACEMENT FOR EXTENDS\n\t    if (false) {\n\t\n\t      module.hot.accept(['./iscroll.detects.js', './mixins/EventEmitter.js', './mixins/EventProcessor.js'], function () {\n\t        _this.off();\n\t        require('./iscroll.detects.js').default(_this); // can be moved out of constructor, due perfomance reasons\n\t\n\t        var EventEmitter = require('./mixins/EventEmitter.js').default;\n\t        var EventProcessor = require('./mixins/EventProcessor.js').default;\n\t\n\t        var events = _this._events;\n\t        var customEvents = _this._customEvents;\n\t\n\t        EventEmitter.apply(_this);\n\t        EventProcessor.apply(_this);\n\t        EventEmitter.extend(Iscroll.prototype);\n\t        EventProcessor.extend(Iscroll.prototype);\n\t\n\t        // restore all previous declared events\n\t        _this._events = events;\n\t        _this._customEvents = customEvents;\n\t      });\n\t    }\n\t  }\n\t\n\t  // return all DOM to initial state, clean up after meal\n\t\n\t  _createClass(Iscroll, [{\n\t    key: 'destructor',\n\t    value: function destructor() {}\n\t\n\t    // force update state\n\t\n\t  }, {\n\t    key: 'update',\n\t    value: function update() {}\n\t\n\t    // force update state\n\t\n\t  }, {\n\t    key: 'refresh',\n\t    value: function refresh() {\n\t      this.state.width = this.container.offsetWidth;\n\t      this.state.height = this.container.offsetHeight;\n\t    }\n\t  }, {\n\t    key: 'destroy',\n\t    value: function destroy() {\n\t      this.destructor();\n\t      this.off();\n\t    }\n\t  }]);\n\t\n\t  return Iscroll;\n\t}();\n\t\n\t_EventEmitter2.default.extend(Iscroll.prototype);\n\t_EventProcessor2.default.extend(Iscroll.prototype);\n\t\n\twindow.Iscroll = Iscroll;\n\tmodule.exports = Iscroll;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * Mixins provides methods used for event manipulating.\n\t *\n\t */\n\t\n\t/**\n\t * emit\n\t * Custom event emitter\n\t * @param {String}  type\n\t * @param {Object}  point\n\t */\n\tfunction emit(type) {\n\t  if (!this._customEvents[type]) {\n\t    return;\n\t  }\n\t\n\t  var i = this._customEvents[type].length;\n\t\n\t  while (i--) {\n\t    this._customEvents[type][i].apply(this, [].slice.call(arguments, 1));\n\t  }\n\t}\n\t\n\t/**\n\t * attach\n\t * Attach a custom event\n\t * @param {String}  type\n\t * @param {Function}  fn\n\t */\n\tfunction attach(type, cb) {\n\t  var _this = this;\n\t\n\t  if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {\n\t    var _iteratorNormalCompletion = true;\n\t    var _didIteratorError = false;\n\t    var _iteratorError = undefined;\n\t\n\t    try {\n\t      for (var _iterator = Object.keys(type)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t        var i = _step.value;\n\t\n\t        this.attach(i, type[i]);\n\t      }\n\t    } catch (err) {\n\t      _didIteratorError = true;\n\t      _iteratorError = err;\n\t    } finally {\n\t      try {\n\t        if (!_iteratorNormalCompletion && _iterator.return) {\n\t          _iterator.return();\n\t        }\n\t      } finally {\n\t        if (_didIteratorError) {\n\t          throw _iteratorError;\n\t        }\n\t      }\n\t    }\n\t\n\t    return;\n\t  }\n\t  var types = type.split(' ');\n\t  types.forEach(function (type) {\n\t    if (!_this._customEvents[type]) {\n\t      _this._customEvents[type] = [];\n\t    }\n\t    _this._customEvents[type].push(cb);\n\t  });\n\t}\n\t\n\t/**\n\t * attach\n\t * Attach a custom event\n\t * @param {String}  type\n\t * @param {Function}  fn\n\t */\n\tfunction attachOnce(type, cb) {\n\t\n\t  var callback = function callback() {\n\t    cb();\n\t    this.detach(type, callback);\n\t  };\n\t\n\t  this.attach(type, callback);\n\t}\n\t\n\t/**\n\t * detach\n\t * Detach a custom event\n\t * @param {String}  type\n\t * @param {Function}  fn\n\t */\n\tfunction detach(type, cb) {\n\t  if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {\n\t    for (var i in type) {\n\t      this.detach(i, type[i]);\n\t    }\n\t\n\t    return;\n\t  }\n\t\n\t  if (!this._customEvents[type]) {\n\t    return;\n\t  }\n\t\n\t  if (!cb) {\n\t    this._customEvents[type] = [];\n\t  } else {\n\t    this._customEvents[type].filter(function (item) {\n\t      return item !== cb;\n\t    });\n\t  }\n\t}\n\t\n\t/**\n\t * on\n\t * Attach an event listener\n\t * @param {string}      type - event type name\n\t * @param {HTMLElement} [context=this.container]\n\t * @param {Function}    [cb=this]\n\t */\n\tfunction on(type, context, cb) {\n\t  if (!this._events[type]) {\n\t    this._events[type] = [];\n\t  }\n\t\n\t  cb = cb || this;\n\t  context = context || this.container;\n\t\n\t  this._events[type].push({ cb: cb, context: context });\n\t\n\t  context.addEventListener(type, cb, false);\n\t}\n\t\n\t/**\n\t * off\n\t * Release an event listener. If type is undefined remove all registered events\n\t * @param {string}      [type] - event type name\n\t * @param {HTMLElement} [context=this.container]\n\t * @param {Function}    [cb=this] - callback\n\t */\n\tfunction off(type, context, cb) {\n\t  var i;\n\t\n\t  // if called without parameters remove all events\n\t  if (!type) {\n\t    for (i in this._events) {\n\t      this.off(i, this._events[i].context, this._events[i].cb);\n\t    }\n\t\n\t    return;\n\t  }\n\t\n\t  if (!this._events[type]) {\n\t    return;\n\t  }\n\t\n\t  cb = cb || this;\n\t  context = context || this.container;\n\t\n\t  // we work on a clone of the original array\n\t  var eventArr = this._events[type].slice(0);\n\t\n\t  for (i = eventArr.length; i--;) {\n\t    if (eventArr[i].cb === cb && eventArr[i].context === context) {\n\t      context.removeEventListener(type, cb, false);\n\t      this._events[type].splice(i, 1);\n\t    }\n\t  }\n\t\n\t  if (!this._events[type].length) {\n\t    delete this._events[type];\n\t  }\n\t}\n\t\n\texports.default = {\n\t\n\t  /**\n\t   * apply\n\t   * Apply event emitter to object\n\t   * @param {Object} object - target object\n\t   */\n\t\n\t  apply: function apply(obj) {\n\t    obj._events = {}; // holds all the Default registered events\n\t    obj._customEvents = {}; // holds all iScroll specific events\n\t  },\n\t\n\t  /**\n\t   * extend\n\t   * Extend object (for prototypes)\n\t   * @param {Object} object - target object\n\t   */\n\t  extend: function extend(obj) {\n\t    Object.assign(obj, { attach: attach, attachOnce: attachOnce, detach: detach, emit: emit, on: on, off: off });\n\t  }\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Mixins provides methods used for event dispatching\n\t *\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _fps = __webpack_require__(3);\n\t\n\t/**\n\t * List all known pointer events\n\t * @const {Object}\n\t */\n\tvar EVENT_TYPE = {\n\t  pointer: {\n\t    start: 'pointerdown',\n\t    move: 'pointermove',\n\t    end: 'pointerup',\n\t    cancel: 'pointercancel'\n\t  },\n\t  MSPointer: {\n\t    start: 'MSPointerDown',\n\t    move: 'MSPointerMove',\n\t    end: 'MSPointerUp',\n\t    cancel: 'MSPointerCancel'\n\t  },\n\t  touch: {\n\t    start: 'touchstart',\n\t    move: 'touchmove',\n\t    end: 'touchend',\n\t    cancel: 'touchcancel'\n\t  },\n\t  mouse: {\n\t    start: 'mousedown',\n\t    move: 'mousemove',\n\t    end: 'mouseup',\n\t    cancel: 'mousecancel'\n\t  }\n\t};\n\t\n\t/**\n\t * List all confogurable events\n\t * @const {Array}\n\t */\n\tvar listOfInternalEvents = [\n\t// basic events\n\t'onReady', 'onRefresh', 'onDestroy',\n\t\n\t// declared on iscroll5\n\t'beforeScrollStart', 'scrollCancel', 'scrollStart', 'scroll', 'scrollEnd', 'flick', 'zoomStart', 'zoomEnd'];\n\t\n\tvar EventHandlingModule = {\n\t  /**\n\t   * handleEvent\n\t   * Global event proxy\n\t   * @param {Object} e - event object\n\t   */\n\t\n\t  handleEvent: function handleEvent(e) {\n\t    switch (e.type) {\n\t      case this.eventType.start:\n\t        this._eventStart(e);\n\t        break;\n\t      case this.eventType.move:\n\t        this._eventMove(e);\n\t        break;\n\t      case this.eventType.end:\n\t      case this.eventType.cancel:\n\t        this._eventEnd(e);\n\t        break;\n\t      case this.eventType.transitionEnd:\n\t        this._eventTransitionEnd(e);\n\t        break;\n\t      case 'orientationchange':\n\t      case 'resize':\n\t        this._eventResize(e);\n\t        break;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * _eventStart\n\t   * Initial user interactions phase\n\t   * @param {Object} e - event object\n\t   */\n\t  _eventStart: function _eventStart(e) {\n\t    if (this.options.preventDefault) {\n\t      e.preventDefault();\n\t    }\n\t\n\t    var events = e.targetTouches || [e];\n\t    var id = undefined,\n\t        x = undefined,\n\t        y = undefined,\n\t        i = undefined,\n\t        l = undefined;\n\t\n\t    for (i = 0, l = events.length; i < l; i++) {\n\t\n\t      id = events[i].identifier || 0;\n\t      x = events[i].pageX;\n\t      y = events[i].pageY;\n\t\n\t      this.globalState.POINTS[id] = {\n\t        instance: this,\n\t        id: id + '',\n\t        phase: 'start',\n\t        initiated: false,\n\t        x: x,\n\t        y: y,\n\t        startX: x,\n\t        startY: y,\n\t        deltaX: 0,\n\t        deltaY: 0,\n\t        startTime: Date.now(),\n\t        currentTime: Date.now()\n\t      };\n\t    }\n\t\n\t    // start the rAF loop\n\t    if (!this.globalState.LOOP) {\n\t      this._renderLoop();\n\t    }\n\t\n\t    // start listening to 'move' and 'end' events only when the drag session is initiated\n\t    // on desktop this should prevent useless mousemove events\n\t    this.on(this.eventType.move, this.options.document);\n\t    this.on(this.eventType.end, this.options.document);\n\t  },\n\t\n\t  /**\n\t   * _eventMove\n\t   * Proceed each pointer move event\n\t   * @param {Object} e - event object\n\t   */\n\t  _eventMove: function _eventMove(e) {\n\t    var events = e.changedTouches || [e];\n\t    var POINTS = this.globalState.POINTS;\n\t\n\t    var id = undefined,\n\t        i = undefined;\n\t\n\t    for (i = events.length; i--;) {\n\t      id = events[i].identifier || 0;\n\t\n\t      if (POINTS[id] && POINTS[id].initiated) {\n\t        POINTS[id] = this._updatePoint(POINTS[id], e);\n\t        POINTS[id].phase = 'move';\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * _eventMove\n\t   * Proceed last interaction event\n\t   * @param {Object} e - event object\n\t   */\n\t  _eventEnd: function _eventEnd(e) {\n\t    var events = e.changedTouches || [e];\n\t    var POINTS = this.globalState.POINTS;\n\t\n\t    var id = undefined,\n\t        i = undefined;\n\t\n\t    for (i = events.length; i--;) {\n\t      id = events[i].identifier || 0;\n\t\n\t      if (POINTS[id] && POINTS[id].initiated) {\n\t        POINTS[id] = this._updatePoint(POINTS[id], e);\n\t        POINTS[id].phase = 'end';\n\t      }\n\t    }\n\t\n\t    this.off(this.eventType.move, this.options.document);\n\t    this.off(this.eventType.end, this.options.document);\n\t  },\n\t\n\t  /**\n\t   * _eventResize\n\t   * Proceed viewport resize event\n\t   * @param {Object} e - event object\n\t   */\n\t  _eventResize: function _eventResize(e) {\n\t    // if we resize before the script has been initialized\n\t    if (!this.state.ready) {\n\t      return this.attachOnce('onReady', this._eventResize.bind(this, e));\n\t    }\n\t\n\t    // debounce the resize event to spare resources\n\t    this._resizeTimeout = setTimeout(this.refresh.bind(this), 100);\n\t  },\n\t\n\t  /**\n\t   * _updatePoint\n\t   * ....\n\t   * @param {Object} point - .....\n\t   * @param {Object} e - event object\n\t   */\n\t  _updatePoint: function _updatePoint(point, e) {\n\t    point.currentTime = Date.now();\n\t\n\t    // distance travelled since last event\n\t    point.deltaX = point.x - e.pageX;\n\t    point.deltaY = point.y - e.pageY;\n\t\n\t    // update current position\n\t    point.x = e.pageX;\n\t    point.y = e.pageY;\n\t\n\t    // distance from start\n\t    var xd = point.startX - point.x;\n\t    var yd = point.startY - point.y;\n\t    point.distance = Math.sqrt(xd * xd + yd * yd);\n\t    point.distanceX = xd;\n\t    point.distanceY = yd;\n\t\n\t    // angle from start (hence direction) 0=right, counter clockwise\n\t    var theta = Math.atan2(yd, -xd);\n\t    if (theta < 0) {\n\t      theta += 2 * Math.PI;\n\t    }\n\t    //theta *= (180 / Math.PI);   // convert to degrees\n\t    point.theta = theta;\n\t\n\t    return point;\n\t  },\n\t\n\t  /**\n\t   * _renderLoop\n\t   * One frame in the requestAnimationFrame loop\n\t   */\n\t  _renderLoop: function _renderLoop() {\n\t    var pointCount = 0;\n\t    var POINTS = this.globalState.POINTS;\n\t\n\t    for (var id in POINTS) {\n\t      var point = POINTS[id];\n\t\n\t      switch (point.phase) {\n\t        case 'start':\n\t          if (!point.initiated) {\n\t            point.initiated = true;\n\t            this.emit('start', point);\n\t          }\n\t          break;\n\t        case 'move':\n\t          this.emit('move', point);\n\t          break;\n\t        case 'end':\n\t          point.initiated = false;\n\t          this.emit('end', point);\n\t          delete POINTS[id];\n\t          break;\n\t      }\n\t\n\t      pointCount++;\n\t    }\n\t\n\t    // keep animating until there are points in the POINTS object\n\t    this.globalState.LOOP = !!pointCount;\n\t\n\t    if (this.globalState.LOOP) {\n\t      (0, _fps.read)(this._renderLoop.bind(this));\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * assignEventsFromOptions\n\t * Extend object with configured event data\n\t * @param {Object} IscrollInstance - instance options\n\t */\n\tvar assignEventsFromOptions = function assignEventsFromOptions(IscrollInstance) {\n\t  var options = IscrollInstance.options;\n\t\n\t  listOfInternalEvents.forEach(function (eventName) {\n\t    if (!options[eventName]) {\n\t      return;\n\t    }\n\t\n\t    IscrollInstance.attach(eventName, options[eventName]);\n\t  });\n\t};\n\t\n\t/**\n\t * detectTransitionEnd\n\t * Find the transitionEnd event based on the vendor, there's no pattern so\n\t * we have to use a function\n\t * @param {Object} detects - object to write detected data\n\t */\n\tvar detectTransitionEnd = function detectTransitionEnd(_ref) {\n\t  var detects = _ref.detects;\n\t  var eventType = _ref.eventType;\n\t\n\t  var types = {\n\t    '': 'transitionend',\n\t    'webkit': 'webkitTransitionEnd',\n\t    'Moz': 'transitionend',\n\t    'O': 'oTransitionEnd',\n\t    'ms': 'MSTransitionEnd'\n\t  };\n\t\n\t  eventType.transitionEnd = types[detects.vendor] || false;\n\t};\n\t\n\texports.default = {\n\t\n\t  /**\n\t   * apply\n\t   * Extend object with configured event data\n\t   * @param {object} type - target object\n\t   */\n\t\n\t  apply: function apply(IscrollInstance) {\n\t    var options = IscrollInstance.options;\n\t    var detects = IscrollInstance.detects;\n\t\n\t    // choose the appropriate event type to use, it can also be forced via options\n\t\n\t    if (options.eventType) {\n\t      IscrollInstance.eventType = EVENT_TYPE[options.eventType];\n\t    } else if (detects.hasPointerEvents) {\n\t      IscrollInstance.eventType = EVENT_TYPE.pointer;\n\t    } else if (detects.hasMSpointerEvents) {\n\t      IscrollInstance.eventType = EVENT_TYPE.MSPointer;\n\t    } else if (detects.useTouchEvents) {\n\t      IscrollInstance.eventType = EVENT_TYPE.touch;\n\t    } else {\n\t      IscrollInstance.eventType = EVENT_TYPE.mouse;\n\t    }\n\t    detectTransitionEnd(IscrollInstance);\n\t\n\t    // bind basic events\n\t    IscrollInstance.on('orientationchange', window);\n\t    IscrollInstance.on('resize', window);\n\t    IscrollInstance.on(IscrollInstance.eventType.start);\n\t    IscrollInstance.on(IscrollInstance.eventType.transitionEnd);\n\t\n\t    // setup events from user config\n\t    assignEventsFromOptions(IscrollInstance);\n\t  },\n\t\n\t  /**\n\t   * extend\n\t   * Extend object (for prototypes)\n\t   * @param {Object} object - target object\n\t   */\n\t  extend: function extend(IscrollPrototype) {\n\t    Object.assign(IscrollPrototype, EventHandlingModule);\n\t  }\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar vendors = ['ms', 'moz', 'webkit', 'o'];\n\t\n\tvar request = window.requestAnimationFrame;\n\tvar cancel = window.cancelAnimationFrame;\n\t\n\tvar lastTime = 0;\n\tvar readers = [];\n\tvar writers = [];\n\tfor (var x = 0; x < vendors.length && !request; ++x) {\n\t  exports.request = request = window[vendors[x] + 'RequestAnimationFrame'];\n\t  exports.cancel = cancel = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n\t}\n\t\n\tif (!request) {\n\t  exports.request = request = function request(callback) {\n\t    var currTime = new Date().getTime();\n\t    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t    var id = setTimeout(function () {\n\t      callback(currTime + timeToCall);\n\t    }, timeToCall);\n\t\n\t    lastTime = currTime + timeToCall;\n\t    return id;\n\t  };\n\t}\n\t\n\tif (!cancel) {\n\t  exports.cancel = cancel = function cancel(id) {\n\t    clearTimeout(id);\n\t  };\n\t}\n\t\n\tvar read = function read(fn) {\n\t  readers.push(fn);\n\t};\n\t\n\tvar write = function write(fn) {\n\t  writers.push(fn);\n\t};\n\t\n\tvar throttle = function throttle(fn) {\n\t  var raf = undefined;\n\t\n\t  return function requestAnimationFrameThrottler() {\n\t    var args = arguments;\n\t    if (raf) {\n\t      cancel(raf);\n\t    }\n\t\n\t    raf = read(function requestAnimationFrameHandler() {\n\t      raf = false;\n\t      fn.apply(this, args);\n\t    });\n\t  };\n\t};\n\t\n\tvar loop = function loop() {\n\t  var read = readers;\n\t  readers = [];\n\t  read.forEach(function (t) {\n\t    return t();\n\t  });\n\t\n\t  var write = writers;\n\t  writers = [];\n\t  write.forEach(function (t) {\n\t    return t();\n\t  });\n\t\n\t  request(loop, 'loop set');\n\t};\n\t\n\trequest(loop, 'loop set');\n\t\n\texports.request = request;\n\texports.cancel = cancel;\n\texports.read = read;\n\texports.write = write;\n\texports.throttle = throttle;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Component, render layer\n\t */\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _easings = __webpack_require__(5);\n\t\n\tvar _fps = __webpack_require__(3);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar RenderLayer = function () {\n\t\n\t  /**\n\t   * constructor\n\t   */\n\t\n\t  function RenderLayer(name, element, IscrollInstance) {\n\t    _classCallCheck(this, RenderLayer);\n\t\n\t    this.parent = IscrollInstance;\n\t    this.container = element;\n\t    this.parent[name] = this;\n\t    this.name = name;\n\t\n\t    var parent = this.parent;\n\t\n\t    if (!parent.state[name]) {\n\t      parent.state[name] = {};\n\t    }\n\t\n\t    this.state = parent.state[name];\n\t\n\t    if (false) {\n\t      // shadowLayer\n\t      var shadowLayer = document.createElement('div');\n\t      shadowLayer.style.position = 'absolute';\n\t      shadowLayer.style.top = 0;\n\t      shadowLayer.style.left = 0;\n\t      shadowLayer.style.border = '1px solid red';\n\t      shadowLayer.style.borderSizing = 'border-box';\n\t      shadowLayer.style.background = 'rgba(255,0,0,0.1)';\n\t      shadowLayer.style.opacity = 0;\n\t      this.shadowLayer = shadowLayer;\n\t      parent.container.appendChild(shadowLayer);\n\t\n\t      // momentumLayerX\n\t      var momentumLayerX = document.createElement('div');\n\t      momentumLayerX.style.position = 'absolute';\n\t      momentumLayerX.style.height = '5px';\n\t      momentumLayerX.style.width = '50%';\n\t      momentumLayerX.style.left = '50%';\n\t      momentumLayerX.style.bottom = 2;\n\t      momentumLayerX.style.transformOrigin = '0% 50%';\n\t      momentumLayerX.style.background = 'rgba(255,0,0,0.5)';\n\t      momentumLayerX.style.transform = 'scaleX(0)';\n\t      this.momentumLayerX = momentumLayerX;\n\t      parent.container.appendChild(momentumLayerX);\n\t\n\t      // momentumLayerX\n\t      var momentumLayerY = document.createElement('div');\n\t      momentumLayerY.style.position = 'absolute';\n\t      momentumLayerY.style.width = '5px';\n\t      momentumLayerY.style.height = '50%';\n\t      momentumLayerY.style.top = '50%';\n\t      momentumLayerY.style.left = 2;\n\t      momentumLayerY.style.transformOrigin = '50% 0%';\n\t      momentumLayerY.style.transform = 'scaleX(0)';\n\t      momentumLayerY.style.background = 'rgba(255,0,0,0.5)';\n\t      this.momentumLayerY = momentumLayerY;\n\t      parent.container.appendChild(momentumLayerY);\n\t    }\n\t\n\t    this.init();\n\t    this.subscribe();\n\t\n\t    this.timeCapsule = []; // keeps time data for momentum\n\t    this.timeCapsuleSize = 15;\n\t  }\n\t\n\t  /**\n\t   * init\n\t   */\n\t\n\t  _createClass(RenderLayer, [{\n\t    key: 'init',\n\t    value: function init() {\n\t      var state = this.state;\n\t      var container = this.container;\n\t\n\t      if (!state.x) {\n\t        state.x = state.currentX = container.offsetLeft;\n\t      }\n\t\n\t      if (!state.y) {\n\t        state.y = state.currentY = container.offsetTop;\n\t      }\n\t\n\t      this.refresh();\n\t    }\n\t\n\t    /**\n\t     * processInteraction\n\t     * Get pointer data from EventProcessor\n\t     * @param {Object} event - pointer event\n\t     */\n\t\n\t  }, {\n\t    key: 'processInteraction',\n\t    value: function processInteraction(e) {\n\t      var state = this.state;\n\t      var timeCapsule = this.timeCapsule;\n\t\n\t      state.isAnimated = false;\n\t\n\t      if (e.phase === 'start') {\n\t        state.startX = state.lastX = state.currentX;\n\t        state.startY = state.lastY = state.currentY;\n\t        timeCapsule.length = 0; // empty array (mutate)\n\t      }\n\t\n\t      // update timecapsule\n\t      timeCapsule.push({\n\t        x: e.x,\n\t        y: e.y,\n\t        time: e.currentTime\n\t      });\n\t      if (timeCapsule.length > this.timeCapsuleSize) {\n\t        timeCapsule.shift();\n\t      }\n\t\n\t      if (e.distanceX && e.distanceY) {\n\t        state.lastX = state.currentX;\n\t        state.lastY = state.currentY;\n\t\n\t        state.currentX = state.startX - e.distanceX;\n\t        state.currentY = state.startY - e.distanceY;\n\t\n\t        this.renderPosition();\n\t      }\n\t\n\t      if (e.phase === 'end') {\n\t        delete state.startX;\n\t        delete state.startY;\n\t\n\t        this.calculateVelocity();\n\t        this.releaseVelocity();\n\t      }\n\t\n\t      if (false) {\n\t        // to display velocity on the corners while development\n\t        this.calculateVelocity();\n\t      }\n\t    }\n\t\n\t    /**\n\t     * getOverscrollX\n\t     * detect overscroll by x\n\t     * @param {Number} x\n\t     * @return {Number} overscroll by x\n\t     */\n\t\n\t  }, {\n\t    key: 'getOverscrollX',\n\t    value: function getOverscrollX(x) {\n\t      var state = this.state;\n\t      var parentState = this.parent.state;\n\t\n\t      var result = 0;\n\t\n\t      if (!x) {\n\t        x = state.currentX;\n\t      }\n\t\n\t      if (x > 0) {\n\t        result = x;\n\t      } else if (state.width + x < parentState.width) {\n\t        result = state.width + x - parentState.width;\n\t      }\n\t\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * getOverscrollY\n\t     * detect overscroll by y\n\t     * @param {Number} y\n\t     * @return {Number} overscroll by y\n\t     */\n\t\n\t  }, {\n\t    key: 'getOverscrollY',\n\t    value: function getOverscrollY(y) {\n\t      var state = this.state;\n\t      var parentState = this.parent.state;\n\t\n\t      var result = 0;\n\t\n\t      if (!y) {\n\t        y = state.currentY;\n\t      }\n\t\n\t      if (y > 0) {\n\t        result = y;\n\t      } else if (state.height + y < parentState.height) {\n\t        result = state.height + y - parentState.height;\n\t      }\n\t\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * renderPosition\n\t     * Render layer position\n\t     */\n\t\n\t  }, {\n\t    key: 'renderPosition',\n\t    value: function renderPosition() {\n\t      var state = this.state;\n\t      var container = this.container;\n\t      var options = this.parent.options;\n\t\n\t      var transform = this.parent.styles.transform;\n\t\n\t      // calculate boundaries and overscrollX\n\t      state.overscrollX = this.getOverscrollX();\n\t      state.overscrollY = this.getOverscrollY();\n\t\n\t      // calculate position\n\t      if (options.scrollX) {\n\t        state.x = state.currentX - (state.overscrollX || 0);\n\t        if (state.overscrollX && options.allowOverscroll) {\n\t          state.x += this.overscrollReducer(state.overscrollX);\n\t        }\n\t      }\n\t\n\t      // calculate position\n\t      if (options.scrollY) {\n\t        state.y = state.currentY - (state.overscrollY || 0);\n\t        if (state.overscrollY && options.allowOverscroll) {\n\t          state.y += this.overscrollReducer(state.overscrollY);\n\t        }\n\t      }\n\t\n\t      // #DEV - display actual layer (not reduced by bounds or thresholds)\n\t      if (false) {\n\t        if (state.overscrollX || state.overscrollY) {\n\t          this.shadowLayer.style[transform] = 'translate3d(' + state.currentX + 'px, ' + state.currentY + 'px, 0px)';\n\t          this.shadowLayer.style.opacity = 1;\n\t        } else if (this.shadowLayer.style.opacity) {\n\t          this.shadowLayer.style.opacity = 0;\n\t        }\n\t      }\n\t\n\t      if (transform) {\n\t        container.style[transform] = 'translate3d(' + state.x + 'px, ' + state.y + 'px, 0px)';\n\t        return;\n\t      }\n\t\n\t      // respect old-fashioned browsers\n\t      container.style.left = this.state.x;\n\t      container.style.top = this.state.y;\n\t    }\n\t\n\t    /**\n\t     * calculateVelocity\n\t     * Calculate interaction velocity\n\t     */\n\t\n\t  }, {\n\t    key: 'calculateVelocity',\n\t    value: function calculateVelocity() {\n\t      var timeCapsule = this.timeCapsule;\n\t      var state = this.state;\n\t\n\t      var firstPoint = timeCapsule[0];\n\t      var lastPoint = timeCapsule[timeCapsule.length - 1];\n\t\n\t      var xOffset = lastPoint.x - firstPoint.x;\n\t      var yOffset = lastPoint.y - firstPoint.y;\n\t      var timeOffset = lastPoint.time - firstPoint.time;\n\t\n\t      var timePerPoint = timeOffset / this.timeCapsule.length;\n\t\n\t      state.velocityX = xOffset / timePerPoint || 0;\n\t      state.velocityY = yOffset / timePerPoint || 0;\n\t\n\t      if (false) {\n\t        this.momentumLayerX.style.transform = 'scaleX(' + state.velocityX / 30 + ')';\n\t        this.momentumLayerY.style.transform = 'scaleY(' + state.velocityY / 30 + ')';\n\t      }\n\t    }\n\t\n\t    /**\n\t     * releaseVelocity\n\t     * Animate layer, based on current velocity\n\t     */\n\t\n\t  }, {\n\t    key: 'releaseVelocity',\n\t    value: function releaseVelocity() {\n\t      var _this = this;\n\t\n\t      var state = this.state;\n\t      var options = this.parent.options;\n\t\n\t      var speedThreshold = 0.3;\n\t      var framesX = 0;\n\t      var framesY = 0;\n\t      var framesDefault = 350 / (1000 / 60); // used then both bounds have been overscrolled\n\t      var distanceX = 0;\n\t      var distanceY = 0;\n\t      var i = 1;\n\t\n\t      if (state.overscrollX && state.overscrollY) {\n\t        return this._animate({\n\t          distanceX: -state.overscrollX || 0,\n\t          distanceY: -state.overscrollY || 0,\n\t          time: 350\n\t        });\n\t      }\n\t\n\t      // calculate how much frames needs to impulse for go out\n\t      if (state.overscrollX) {\n\t        distanceX = -state.overscrollX;\n\t      } else if (state.velocityX && Math.abs(state.velocityX) > speedThreshold) {\n\t        framesX = Math.abs(Math.ceil(Math.log(speedThreshold / Math.abs(state.velocityX)) / Math.log(options.friction)));\n\t        while (i <= framesX) {\n\t          distanceX += state.velocityX * Math.pow(options.friction, i);\n\t          i++;\n\t        }\n\t      }\n\t\n\t      if (state.overscrollY) {\n\t        distanceY = -state.overscrollY;\n\t      } else if (state.velocityY && Math.abs(state.velocityY) > speedThreshold) {\n\t        framesY = Math.abs(Math.ceil(Math.log(speedThreshold / Math.abs(state.velocityY)) / Math.log(options.friction)));\n\t        i = 1;\n\t        while (i <= framesY) {\n\t          distanceY += state.velocityY * Math.pow(options.friction, i);\n\t          i++;\n\t        }\n\t      }\n\t\n\t      var frames = Math.abs(framesDefault, framesY, framesX);\n\t\n\t      this._animate({\n\t        distanceX: distanceX, distanceY: distanceY, frames: frames,\n\t        callback: function callback() {\n\t          // check if destination points makes us to feel little bit overscrolled.\n\t          if (state.overscrollX || state.overscrollY) {\n\t            return _this._animate({\n\t              distanceX: -state.overscrollX || 0,\n\t              distanceY: -state.overscrollY || 0,\n\t              time: 350\n\t            });\n\t          }\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * _animate\n\t     * Internal function to provide flexible api for animations. Used as internal method.\n\t     * @param  {Object} option\n\t     */\n\t\n\t  }, {\n\t    key: '_animate',\n\t    value: function _animate(_ref) {\n\t      var _this2 = this;\n\t\n\t      var distanceX = _ref.distanceX;\n\t      var distanceY = _ref.distanceY;\n\t      var easing = _ref.easing;\n\t      var frames = _ref.frames;\n\t      var time = _ref.time;\n\t      var callback = _ref.callback;\n\t      var state = this.state;\n\t\n\t      var startX = state.currentX;\n\t      var startY = state.currentY;\n\t      var currentFrame = 0;\n\t\n\t      if (!frames && time) {\n\t        frames = time / (1000 / 60);\n\t      }\n\t\n\t      if (!easing) {\n\t        easing = _easings.inertia;\n\t      }\n\t\n\t      state.isAnimated = true;\n\t\n\t      var tick = function tick() {\n\t        if (!state.isAnimated) {\n\t          return;\n\t        }\n\t\n\t        state.currentX = easing(currentFrame, startX, distanceX, frames);\n\t        state.currentY = easing(currentFrame, startY, distanceY, frames);\n\t\n\t        _this2.renderPosition();\n\t\n\t        currentFrame++;\n\t        if (currentFrame < frames) {\n\t          (0, _fps.write)(tick);\n\t        } else {\n\t          state.isAnimated = false;\n\t          if (typeof callback === 'function') {\n\t            callback();\n\t          }\n\t        }\n\t      };\n\t\n\t      (0, _fps.write)(tick);\n\t    }\n\t\n\t    /**\n\t     * overscrollReducer\n\t     * Reduce ammount of overscroll\n\t     * @param {Number} value - ammout of overscroll\n\t     * @return {Number} result - reduced ammount\n\t     */\n\t\n\t  }, {\n\t    key: 'overscrollReducer',\n\t    value: function overscrollReducer(value) {\n\t      var direction = value > 0 ? 1 : -1;\n\t      var i = Math.abs(value);\n\t      var results = 0;\n\t      while (i > 0) {\n\t        results += 1 / Math.pow(1.0035, i) * direction;\n\t        i--;\n\t      }\n\t\n\t      return results;\n\t    }\n\t\n\t    /**\n\t     * subscribe\n\t     * Subsribe to pointer events\n\t     */\n\t\n\t  }, {\n\t    key: 'subscribe',\n\t    value: function subscribe() {\n\t      this.processInteraction = this.processInteraction.bind(this);\n\t      this.parent.attach('start move end', this.processInteraction);\n\t    }\n\t\n\t    /**\n\t     * subscribe\n\t     * Unsubscribe from anything\n\t     */\n\t\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe() {\n\t      this.parent.detach('start move end', this.processInteraction);\n\t    }\n\t\n\t    /**\n\t     * refresh\n\t     * Refresh component data\n\t     */\n\t\n\t  }, {\n\t    key: 'refresh',\n\t    value: function refresh() {\n\t      var state = this.state;\n\t      var container = this.container;\n\t\n\t      state.width = container.offsetWidth;\n\t      state.height = container.offsetHeight;\n\t\n\t      if (false) {\n\t        this.shadowLayer.style.width = state.width;\n\t        this.shadowLayer.style.height = state.height;\n\t      }\n\t    }\n\t\n\t    /**\n\t     * destroy\n\t     * destroy function\n\t     */\n\t\n\t  }, {\n\t    key: 'destroy',\n\t    value: function destroy() {\n\t      this.unsubscribe();\n\t\n\t      if (false) {\n\t        this.parent.container.removeChild(this.shadowLayer);\n\t        this.parent.container.removeChild(this.momentumLayerX);\n\t        this.parent.container.removeChild(this.momentumLayerY);\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return RenderLayer;\n\t}();\n\t\n\texports.default = RenderLayer;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * Easings collection\n\t */\n\t\n\t/**\n\t * Inertia easing\n\t * @param {Number} currentFrame\n\t * @param {Number} currentValue\n\t * @param {Number} ammountOfChange\n\t * @param {Number} totalFrames\n\t */\n\tvar inertia = function inertia(t, b, c, d) {\n\t  return c * ((t = t / d - 1) * t * t + 1) + b;\n\t};\n\t\n\texports.inertia = inertia;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = {\n\t  eventType: undefined, // what event type will be used. undefined = autodetect\n\t  'document': document, // the bottom most DOM element used for \"move\" and \"end\" events\n\t  preventDefault: true,\n\t\n\t  // scrolling\n\t  allowOverscroll: true,\n\t  scrollY: true,\n\t  scrollX: true,\n\t\n\t  // momentum\n\t  friction: 0.92,\n\t\n\t  // events\n\t  onReady: undefined\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Part, detects environment, supports, etc\n\t *\n\t */\n\t'use strict';\n\t\n\t/**\n\t * detectVendorPrefix\n\t * Browser vendor, used to apply CSS properties\n\t * @param {Object} detects - object to write detected data\n\t */\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar detectVendorPrefix = function detectVendorPrefix(detects) {\n\t  var elementStyle = document.createElement('div').style;\n\t  var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'];\n\t  var vendor = false;\n\t\n\t  for (var i = 0, l = vendors.length; i < l; i++) {\n\t    if (vendors[i] + 'ransform' in elementStyle) {\n\t      vendor = vendors[i].substr(0, vendors[i].length - 1);\n\t      break;\n\t    }\n\t  }\n\t\n\t  detects.vendor = vendor;\n\t};\n\t\n\t/**\n\t * prefixCSSProperty\n\t * If needed prefix the CSS property with the vendor specific version\n\t * @param {string}   style - property to prefix\n\t * @param {Object} detects - object to write detected data\n\t */\n\tvar prefixCSSProperty = function prefixCSSProperty(style, detects) {\n\t  var vendor = detects.vendor;\n\t\n\t  if (vendor === false) {\n\t    return false;\n\t  }\n\t\n\t  var elementStyle = document.createElement('div').style;\n\t  style = vendor === '' ? style : vendor + style.charAt(0).toUpperCase() + style.substr(1);\n\t  return style in elementStyle && style;\n\t};\n\t\n\t/**\n\t * detectPointerEvents\n\t * Find what kind of events supports on client\n\t * @param {Object} detects - object to write detected data\n\t */\n\tvar detectPointerEvents = function detectPointerEvents(detects) {\n\t\n\t  Object.assign(detects, {\n\t    hasPointerEvents: !!window.navigator.pointerEnabled,\n\t    hasMSpointerEvents: !!window.navigator.msPointerEnabled,\n\t\n\t    // we are going to use user agent spoofing to prevent touch events on desktop. TODO: can it be done w/o spoofing?\n\t    useTouchEvents: 'ontouchstart' in window && /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(window.navigator.userAgent)\n\t  });\n\t\n\t  detects.useMouseEvents = !detects.hasPointerEvents && !detects.hasMSpointerEvents && !detects.useTouchEvents;\n\t};\n\t\n\t/**\n\t * apply\n\t * Extend object with calculated client data\n\t * @param {object} IscrollPrototype - target object\n\t */\n\t\n\texports.default = function (IscrollPrototype) {\n\t  IscrollPrototype.detects = {};\n\t  IscrollPrototype.styles = {};\n\t  var detects = IscrollPrototype.detects;\n\t  var styles = IscrollPrototype.styles;\n\t\n\t  // run detects;\n\t\n\t  detectPointerEvents(detects);\n\t  detectVendorPrefix(detects);\n\t\n\t  // run style prefixes (#should move out of here soon)\n\t  Object.assign(styles, {\n\t    transform: prefixCSSProperty('transform', detects),\n\t    transitionDuration: prefixCSSProperty('transitionDuration', detects)\n\t  });\n\t};\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** iscroll.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c723a952dadaa99f52da\n **/","/*!\n * iScroll by Matteo \"Cubiq\" Spinelli ~ http://cubiq.org ~ Released under MIT license\n */\n'use strict';\n\n// example of debug tool. All debug code will strip on production\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _EventEmitter = require('./mixins/EventEmitter.js');\n\nvar _EventEmitter2 = _interopRequireDefault(_EventEmitter);\n\nvar _EventProcessor = require('./mixins/EventProcessor.js');\n\nvar _EventProcessor2 = _interopRequireDefault(_EventProcessor);\n\nvar _RenderLayer = require('./components/RenderLayer.js');\n\nvar _RenderLayer2 = _interopRequireDefault(_RenderLayer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nif (NODE_ENV === 'development') {\n  var _debug = require('./dev/debug.js')('iscroll:iscroll.js');\n  window.debug.enable('iscroll:*');\n}\n\n/**\n * global Object, with\n * @type {Object}\n */\nvar globalState = {\n  LOOP: false,\n  POINTS: []\n};\n\n/**\n * IScroll\n * Main sandbox\n * @class\n */\n\nvar Iscroll = function () {\n\n  /**\n   * Constructor\n   * @param  {(HTMLElement|string\\jQueryElement)} el - The initiator element\n   * @param  {Object} [options]\n   */\n\n  function Iscroll(element) {\n    var _this = this;\n\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Iscroll);\n\n\n    window.iscroll = this;\n\n    if (element.jquery) {\n      element = element[0];\n    }\n    if (typeof element === 'string') {\n      element = document.querySelector(element);\n    }\n    if (!element) {\n      throw 'Element is not defined!';\n    }\n\n    this.container = element;\n    this.options = Object.assign({}, require('./iscroll.options.js'), options);\n    this.state = {};\n    this.globalState = globalState;\n\n    // EXTENDS\n    require('./iscroll.detects.js').default(this); // can be moved out of constructor, due perfomance reasons\n    _EventEmitter2.default.apply(this);\n    _EventProcessor2.default.apply(this);\n\n    // RENDERING\n    new _RenderLayer2.default('viewLayer', this.container.firstElementChild, this);\n\n    this.refresh();\n    this.state.ready = true;\n\n    this.emit('onReady');\n\n    // #DEV - ADDITIONAL MODULES\n    if (NODE_ENV === 'development') {\n      require('./dev/StatePanel.js').default(this); // State display panel\n    }\n\n    // #DEV - HOT MODULE REPLACEMENT FOR EXTENDS\n    if (module.hot) {\n\n      module.hot.accept(['./iscroll.detects.js', './mixins/EventEmitter.js', './mixins/EventProcessor.js'], function () {\n        _this.off();\n        require('./iscroll.detects.js').default(_this); // can be moved out of constructor, due perfomance reasons\n\n        var EventEmitter = require('./mixins/EventEmitter.js').default;\n        var EventProcessor = require('./mixins/EventProcessor.js').default;\n\n        var events = _this._events;\n        var customEvents = _this._customEvents;\n\n        EventEmitter.apply(_this);\n        EventProcessor.apply(_this);\n        EventEmitter.extend(Iscroll.prototype);\n        EventProcessor.extend(Iscroll.prototype);\n\n        // restore all previous declared events\n        _this._events = events;\n        _this._customEvents = customEvents;\n      });\n    }\n  }\n\n  // return all DOM to initial state, clean up after meal\n\n  _createClass(Iscroll, [{\n    key: 'destructor',\n    value: function destructor() {}\n\n    // force update state\n\n  }, {\n    key: 'update',\n    value: function update() {}\n\n    // force update state\n\n  }, {\n    key: 'refresh',\n    value: function refresh() {\n      this.state.width = this.container.offsetWidth;\n      this.state.height = this.container.offsetHeight;\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.destructor();\n      this.off();\n    }\n  }]);\n\n  return Iscroll;\n}();\n\n_EventEmitter2.default.extend(Iscroll.prototype);\n_EventProcessor2.default.extend(Iscroll.prototype);\n\nwindow.Iscroll = Iscroll;\nmodule.exports = Iscroll;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./iscroll.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Mixins provides methods used for event manipulating.\n *\n */\n\n/**\n * emit\n * Custom event emitter\n * @param {String}  type\n * @param {Object}  point\n */\nfunction emit(type) {\n  if (!this._customEvents[type]) {\n    return;\n  }\n\n  var i = this._customEvents[type].length;\n\n  while (i--) {\n    this._customEvents[type][i].apply(this, [].slice.call(arguments, 1));\n  }\n}\n\n/**\n * attach\n * Attach a custom event\n * @param {String}  type\n * @param {Function}  fn\n */\nfunction attach(type, cb) {\n  var _this = this;\n\n  if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = Object.keys(type)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var i = _step.value;\n\n        this.attach(i, type[i]);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return;\n  }\n  var types = type.split(' ');\n  types.forEach(function (type) {\n    if (!_this._customEvents[type]) {\n      _this._customEvents[type] = [];\n    }\n    _this._customEvents[type].push(cb);\n  });\n}\n\n/**\n * attach\n * Attach a custom event\n * @param {String}  type\n * @param {Function}  fn\n */\nfunction attachOnce(type, cb) {\n\n  var callback = function callback() {\n    cb();\n    this.detach(type, callback);\n  };\n\n  this.attach(type, callback);\n}\n\n/**\n * detach\n * Detach a custom event\n * @param {String}  type\n * @param {Function}  fn\n */\nfunction detach(type, cb) {\n  if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {\n    for (var i in type) {\n      this.detach(i, type[i]);\n    }\n\n    return;\n  }\n\n  if (!this._customEvents[type]) {\n    return;\n  }\n\n  if (!cb) {\n    this._customEvents[type] = [];\n  } else {\n    this._customEvents[type].filter(function (item) {\n      return item !== cb;\n    });\n  }\n}\n\n/**\n * on\n * Attach an event listener\n * @param {string}      type - event type name\n * @param {HTMLElement} [context=this.container]\n * @param {Function}    [cb=this]\n */\nfunction on(type, context, cb) {\n  if (!this._events[type]) {\n    this._events[type] = [];\n  }\n\n  cb = cb || this;\n  context = context || this.container;\n\n  this._events[type].push({ cb: cb, context: context });\n\n  context.addEventListener(type, cb, false);\n}\n\n/**\n * off\n * Release an event listener. If type is undefined remove all registered events\n * @param {string}      [type] - event type name\n * @param {HTMLElement} [context=this.container]\n * @param {Function}    [cb=this] - callback\n */\nfunction off(type, context, cb) {\n  var i;\n\n  // if called without parameters remove all events\n  if (!type) {\n    for (i in this._events) {\n      this.off(i, this._events[i].context, this._events[i].cb);\n    }\n\n    return;\n  }\n\n  if (!this._events[type]) {\n    return;\n  }\n\n  cb = cb || this;\n  context = context || this.container;\n\n  // we work on a clone of the original array\n  var eventArr = this._events[type].slice(0);\n\n  for (i = eventArr.length; i--;) {\n    if (eventArr[i].cb === cb && eventArr[i].context === context) {\n      context.removeEventListener(type, cb, false);\n      this._events[type].splice(i, 1);\n    }\n  }\n\n  if (!this._events[type].length) {\n    delete this._events[type];\n  }\n}\n\nexports.default = {\n\n  /**\n   * apply\n   * Apply event emitter to object\n   * @param {Object} object - target object\n   */\n\n  apply: function apply(obj) {\n    obj._events = {}; // holds all the Default registered events\n    obj._customEvents = {}; // holds all iScroll specific events\n  },\n\n  /**\n   * extend\n   * Extend object (for prototypes)\n   * @param {Object} object - target object\n   */\n  extend: function extend(obj) {\n    Object.assign(obj, { attach: attach, attachOnce: attachOnce, detach: detach, emit: emit, on: on, off: off });\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mixins/EventEmitter.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * Mixins provides methods used for event dispatching\n *\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fps = require('../libs/fps.js');\n\n/**\n * List all known pointer events\n * @const {Object}\n */\nvar EVENT_TYPE = {\n  pointer: {\n    start: 'pointerdown',\n    move: 'pointermove',\n    end: 'pointerup',\n    cancel: 'pointercancel'\n  },\n  MSPointer: {\n    start: 'MSPointerDown',\n    move: 'MSPointerMove',\n    end: 'MSPointerUp',\n    cancel: 'MSPointerCancel'\n  },\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    end: 'touchend',\n    cancel: 'touchcancel'\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    end: 'mouseup',\n    cancel: 'mousecancel'\n  }\n};\n\n/**\n * List all confogurable events\n * @const {Array}\n */\nvar listOfInternalEvents = [\n// basic events\n'onReady', 'onRefresh', 'onDestroy',\n\n// declared on iscroll5\n'beforeScrollStart', 'scrollCancel', 'scrollStart', 'scroll', 'scrollEnd', 'flick', 'zoomStart', 'zoomEnd'];\n\nvar EventHandlingModule = {\n  /**\n   * handleEvent\n   * Global event proxy\n   * @param {Object} e - event object\n   */\n\n  handleEvent: function handleEvent(e) {\n    switch (e.type) {\n      case this.eventType.start:\n        this._eventStart(e);\n        break;\n      case this.eventType.move:\n        this._eventMove(e);\n        break;\n      case this.eventType.end:\n      case this.eventType.cancel:\n        this._eventEnd(e);\n        break;\n      case this.eventType.transitionEnd:\n        this._eventTransitionEnd(e);\n        break;\n      case 'orientationchange':\n      case 'resize':\n        this._eventResize(e);\n        break;\n    }\n  },\n\n  /**\n   * _eventStart\n   * Initial user interactions phase\n   * @param {Object} e - event object\n   */\n  _eventStart: function _eventStart(e) {\n    if (this.options.preventDefault) {\n      e.preventDefault();\n    }\n\n    var events = e.targetTouches || [e];\n    var id = undefined,\n        x = undefined,\n        y = undefined,\n        i = undefined,\n        l = undefined;\n\n    for (i = 0, l = events.length; i < l; i++) {\n\n      id = events[i].identifier || 0;\n      x = events[i].pageX;\n      y = events[i].pageY;\n\n      this.globalState.POINTS[id] = {\n        instance: this,\n        id: id + '',\n        phase: 'start',\n        initiated: false,\n        x: x,\n        y: y,\n        startX: x,\n        startY: y,\n        deltaX: 0,\n        deltaY: 0,\n        startTime: Date.now(),\n        currentTime: Date.now()\n      };\n    }\n\n    // start the rAF loop\n    if (!this.globalState.LOOP) {\n      this._renderLoop();\n    }\n\n    // start listening to 'move' and 'end' events only when the drag session is initiated\n    // on desktop this should prevent useless mousemove events\n    this.on(this.eventType.move, this.options.document);\n    this.on(this.eventType.end, this.options.document);\n  },\n\n  /**\n   * _eventMove\n   * Proceed each pointer move event\n   * @param {Object} e - event object\n   */\n  _eventMove: function _eventMove(e) {\n    var events = e.changedTouches || [e];\n    var POINTS = this.globalState.POINTS;\n\n    var id = undefined,\n        i = undefined;\n\n    for (i = events.length; i--;) {\n      id = events[i].identifier || 0;\n\n      if (POINTS[id] && POINTS[id].initiated) {\n        POINTS[id] = this._updatePoint(POINTS[id], e);\n        POINTS[id].phase = 'move';\n      }\n    }\n  },\n\n  /**\n   * _eventMove\n   * Proceed last interaction event\n   * @param {Object} e - event object\n   */\n  _eventEnd: function _eventEnd(e) {\n    var events = e.changedTouches || [e];\n    var POINTS = this.globalState.POINTS;\n\n    var id = undefined,\n        i = undefined;\n\n    for (i = events.length; i--;) {\n      id = events[i].identifier || 0;\n\n      if (POINTS[id] && POINTS[id].initiated) {\n        POINTS[id] = this._updatePoint(POINTS[id], e);\n        POINTS[id].phase = 'end';\n      }\n    }\n\n    this.off(this.eventType.move, this.options.document);\n    this.off(this.eventType.end, this.options.document);\n  },\n\n  /**\n   * _eventResize\n   * Proceed viewport resize event\n   * @param {Object} e - event object\n   */\n  _eventResize: function _eventResize(e) {\n    // if we resize before the script has been initialized\n    if (!this.state.ready) {\n      return this.attachOnce('onReady', this._eventResize.bind(this, e));\n    }\n\n    // debounce the resize event to spare resources\n    this._resizeTimeout = setTimeout(this.refresh.bind(this), 100);\n  },\n\n  /**\n   * _updatePoint\n   * ....\n   * @param {Object} point - .....\n   * @param {Object} e - event object\n   */\n  _updatePoint: function _updatePoint(point, e) {\n    point.currentTime = Date.now();\n\n    // distance travelled since last event\n    point.deltaX = point.x - e.pageX;\n    point.deltaY = point.y - e.pageY;\n\n    // update current position\n    point.x = e.pageX;\n    point.y = e.pageY;\n\n    // distance from start\n    var xd = point.startX - point.x;\n    var yd = point.startY - point.y;\n    point.distance = Math.sqrt(xd * xd + yd * yd);\n    point.distanceX = xd;\n    point.distanceY = yd;\n\n    // angle from start (hence direction) 0=right, counter clockwise\n    var theta = Math.atan2(yd, -xd);\n    if (theta < 0) {\n      theta += 2 * Math.PI;\n    }\n    //theta *= (180 / Math.PI);   // convert to degrees\n    point.theta = theta;\n\n    return point;\n  },\n\n  /**\n   * _renderLoop\n   * One frame in the requestAnimationFrame loop\n   */\n  _renderLoop: function _renderLoop() {\n    var pointCount = 0;\n    var POINTS = this.globalState.POINTS;\n\n    for (var id in POINTS) {\n      var point = POINTS[id];\n\n      switch (point.phase) {\n        case 'start':\n          if (!point.initiated) {\n            point.initiated = true;\n            this.emit('start', point);\n          }\n          break;\n        case 'move':\n          this.emit('move', point);\n          break;\n        case 'end':\n          point.initiated = false;\n          this.emit('end', point);\n          delete POINTS[id];\n          break;\n      }\n\n      pointCount++;\n    }\n\n    // keep animating until there are points in the POINTS object\n    this.globalState.LOOP = !!pointCount;\n\n    if (this.globalState.LOOP) {\n      (0, _fps.read)(this._renderLoop.bind(this));\n    }\n  }\n};\n\n/**\n * assignEventsFromOptions\n * Extend object with configured event data\n * @param {Object} IscrollInstance - instance options\n */\nvar assignEventsFromOptions = function assignEventsFromOptions(IscrollInstance) {\n  var options = IscrollInstance.options;\n\n  listOfInternalEvents.forEach(function (eventName) {\n    if (!options[eventName]) {\n      return;\n    }\n\n    IscrollInstance.attach(eventName, options[eventName]);\n  });\n};\n\n/**\n * detectTransitionEnd\n * Find the transitionEnd event based on the vendor, there's no pattern so\n * we have to use a function\n * @param {Object} detects - object to write detected data\n */\nvar detectTransitionEnd = function detectTransitionEnd(_ref) {\n  var detects = _ref.detects;\n  var eventType = _ref.eventType;\n\n  var types = {\n    '': 'transitionend',\n    'webkit': 'webkitTransitionEnd',\n    'Moz': 'transitionend',\n    'O': 'oTransitionEnd',\n    'ms': 'MSTransitionEnd'\n  };\n\n  eventType.transitionEnd = types[detects.vendor] || false;\n};\n\nexports.default = {\n\n  /**\n   * apply\n   * Extend object with configured event data\n   * @param {object} type - target object\n   */\n\n  apply: function apply(IscrollInstance) {\n    var options = IscrollInstance.options;\n    var detects = IscrollInstance.detects;\n\n    // choose the appropriate event type to use, it can also be forced via options\n\n    if (options.eventType) {\n      IscrollInstance.eventType = EVENT_TYPE[options.eventType];\n    } else if (detects.hasPointerEvents) {\n      IscrollInstance.eventType = EVENT_TYPE.pointer;\n    } else if (detects.hasMSpointerEvents) {\n      IscrollInstance.eventType = EVENT_TYPE.MSPointer;\n    } else if (detects.useTouchEvents) {\n      IscrollInstance.eventType = EVENT_TYPE.touch;\n    } else {\n      IscrollInstance.eventType = EVENT_TYPE.mouse;\n    }\n    detectTransitionEnd(IscrollInstance);\n\n    // bind basic events\n    IscrollInstance.on('orientationchange', window);\n    IscrollInstance.on('resize', window);\n    IscrollInstance.on(IscrollInstance.eventType.start);\n    IscrollInstance.on(IscrollInstance.eventType.transitionEnd);\n\n    // setup events from user config\n    assignEventsFromOptions(IscrollInstance);\n  },\n\n  /**\n   * extend\n   * Extend object (for prototypes)\n   * @param {Object} object - target object\n   */\n  extend: function extend(IscrollPrototype) {\n    Object.assign(IscrollPrototype, EventHandlingModule);\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mixins/EventProcessor.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar vendors = ['ms', 'moz', 'webkit', 'o'];\n\nvar request = window.requestAnimationFrame;\nvar cancel = window.cancelAnimationFrame;\n\nvar lastTime = 0;\nvar readers = [];\nvar writers = [];\nfor (var x = 0; x < vendors.length && !request; ++x) {\n  exports.request = request = window[vendors[x] + 'RequestAnimationFrame'];\n  exports.cancel = cancel = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n}\n\nif (!request) {\n  exports.request = request = function request(callback) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n}\n\nif (!cancel) {\n  exports.cancel = cancel = function cancel(id) {\n    clearTimeout(id);\n  };\n}\n\nvar read = function read(fn) {\n  readers.push(fn);\n};\n\nvar write = function write(fn) {\n  writers.push(fn);\n};\n\nvar throttle = function throttle(fn) {\n  var raf = undefined;\n\n  return function requestAnimationFrameThrottler() {\n    var args = arguments;\n    if (raf) {\n      cancel(raf);\n    }\n\n    raf = read(function requestAnimationFrameHandler() {\n      raf = false;\n      fn.apply(this, args);\n    });\n  };\n};\n\nvar loop = function loop() {\n  var read = readers;\n  readers = [];\n  read.forEach(function (t) {\n    return t();\n  });\n\n  var write = writers;\n  writers = [];\n  write.forEach(function (t) {\n    return t();\n  });\n\n  request(loop, 'loop set');\n};\n\nrequest(loop, 'loop set');\n\nexports.request = request;\nexports.cancel = cancel;\nexports.read = read;\nexports.write = write;\nexports.throttle = throttle;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./libs/fps.js\n ** module id = 3\n ** module chunks = 0\n **/","/**\n * Component, render layer\n */\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _easings = require('../libs/easings.js');\n\nvar _fps = require('../libs/fps.js');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar RenderLayer = function () {\n\n  /**\n   * constructor\n   */\n\n  function RenderLayer(name, element, IscrollInstance) {\n    _classCallCheck(this, RenderLayer);\n\n    this.parent = IscrollInstance;\n    this.container = element;\n    this.parent[name] = this;\n    this.name = name;\n\n    var parent = this.parent;\n\n    if (!parent.state[name]) {\n      parent.state[name] = {};\n    }\n\n    this.state = parent.state[name];\n\n    if (NODE_ENV === 'development') {\n      // shadowLayer\n      var shadowLayer = document.createElement('div');\n      shadowLayer.style.position = 'absolute';\n      shadowLayer.style.top = 0;\n      shadowLayer.style.left = 0;\n      shadowLayer.style.border = '1px solid red';\n      shadowLayer.style.borderSizing = 'border-box';\n      shadowLayer.style.background = 'rgba(255,0,0,0.1)';\n      shadowLayer.style.opacity = 0;\n      this.shadowLayer = shadowLayer;\n      parent.container.appendChild(shadowLayer);\n\n      // momentumLayerX\n      var momentumLayerX = document.createElement('div');\n      momentumLayerX.style.position = 'absolute';\n      momentumLayerX.style.height = '5px';\n      momentumLayerX.style.width = '50%';\n      momentumLayerX.style.left = '50%';\n      momentumLayerX.style.bottom = 2;\n      momentumLayerX.style.transformOrigin = '0% 50%';\n      momentumLayerX.style.background = 'rgba(255,0,0,0.5)';\n      momentumLayerX.style.transform = 'scaleX(0)';\n      this.momentumLayerX = momentumLayerX;\n      parent.container.appendChild(momentumLayerX);\n\n      // momentumLayerX\n      var momentumLayerY = document.createElement('div');\n      momentumLayerY.style.position = 'absolute';\n      momentumLayerY.style.width = '5px';\n      momentumLayerY.style.height = '50%';\n      momentumLayerY.style.top = '50%';\n      momentumLayerY.style.left = 2;\n      momentumLayerY.style.transformOrigin = '50% 0%';\n      momentumLayerY.style.transform = 'scaleX(0)';\n      momentumLayerY.style.background = 'rgba(255,0,0,0.5)';\n      this.momentumLayerY = momentumLayerY;\n      parent.container.appendChild(momentumLayerY);\n    }\n\n    this.init();\n    this.subscribe();\n\n    this.timeCapsule = []; // keeps time data for momentum\n    this.timeCapsuleSize = 15;\n  }\n\n  /**\n   * init\n   */\n\n  _createClass(RenderLayer, [{\n    key: 'init',\n    value: function init() {\n      var state = this.state;\n      var container = this.container;\n\n      if (!state.x) {\n        state.x = state.currentX = container.offsetLeft;\n      }\n\n      if (!state.y) {\n        state.y = state.currentY = container.offsetTop;\n      }\n\n      this.refresh();\n    }\n\n    /**\n     * processInteraction\n     * Get pointer data from EventProcessor\n     * @param {Object} event - pointer event\n     */\n\n  }, {\n    key: 'processInteraction',\n    value: function processInteraction(e) {\n      var state = this.state;\n      var timeCapsule = this.timeCapsule;\n\n      state.isAnimated = false;\n\n      if (e.phase === 'start') {\n        state.startX = state.lastX = state.currentX;\n        state.startY = state.lastY = state.currentY;\n        timeCapsule.length = 0; // empty array (mutate)\n      }\n\n      // update timecapsule\n      timeCapsule.push({\n        x: e.x,\n        y: e.y,\n        time: e.currentTime\n      });\n      if (timeCapsule.length > this.timeCapsuleSize) {\n        timeCapsule.shift();\n      }\n\n      if (e.distanceX && e.distanceY) {\n        state.lastX = state.currentX;\n        state.lastY = state.currentY;\n\n        state.currentX = state.startX - e.distanceX;\n        state.currentY = state.startY - e.distanceY;\n\n        this.renderPosition();\n      }\n\n      if (e.phase === 'end') {\n        delete state.startX;\n        delete state.startY;\n\n        this.calculateVelocity();\n        this.releaseVelocity();\n      }\n\n      if (NODE_ENV === 'development') {\n        // to display velocity on the corners while development\n        this.calculateVelocity();\n      }\n    }\n\n    /**\n     * getOverscrollX\n     * detect overscroll by x\n     * @param {Number} x\n     * @return {Number} overscroll by x\n     */\n\n  }, {\n    key: 'getOverscrollX',\n    value: function getOverscrollX(x) {\n      var state = this.state;\n      var parentState = this.parent.state;\n\n      var result = 0;\n\n      if (!x) {\n        x = state.currentX;\n      }\n\n      if (x > 0) {\n        result = x;\n      } else if (state.width + x < parentState.width) {\n        result = state.width + x - parentState.width;\n      }\n\n      return result;\n    }\n\n    /**\n     * getOverscrollY\n     * detect overscroll by y\n     * @param {Number} y\n     * @return {Number} overscroll by y\n     */\n\n  }, {\n    key: 'getOverscrollY',\n    value: function getOverscrollY(y) {\n      var state = this.state;\n      var parentState = this.parent.state;\n\n      var result = 0;\n\n      if (!y) {\n        y = state.currentY;\n      }\n\n      if (y > 0) {\n        result = y;\n      } else if (state.height + y < parentState.height) {\n        result = state.height + y - parentState.height;\n      }\n\n      return result;\n    }\n\n    /**\n     * renderPosition\n     * Render layer position\n     */\n\n  }, {\n    key: 'renderPosition',\n    value: function renderPosition() {\n      var state = this.state;\n      var container = this.container;\n      var options = this.parent.options;\n\n      var transform = this.parent.styles.transform;\n\n      // calculate boundaries and overscrollX\n      state.overscrollX = this.getOverscrollX();\n      state.overscrollY = this.getOverscrollY();\n\n      // calculate position\n      if (options.scrollX) {\n        state.x = state.currentX - (state.overscrollX || 0);\n        if (state.overscrollX && options.allowOverscroll) {\n          state.x += this.overscrollReducer(state.overscrollX);\n        }\n      }\n\n      // calculate position\n      if (options.scrollY) {\n        state.y = state.currentY - (state.overscrollY || 0);\n        if (state.overscrollY && options.allowOverscroll) {\n          state.y += this.overscrollReducer(state.overscrollY);\n        }\n      }\n\n      // #DEV - display actual layer (not reduced by bounds or thresholds)\n      if (NODE_ENV === 'development') {\n        if (state.overscrollX || state.overscrollY) {\n          this.shadowLayer.style[transform] = 'translate3d(' + state.currentX + 'px, ' + state.currentY + 'px, 0px)';\n          this.shadowLayer.style.opacity = 1;\n        } else if (this.shadowLayer.style.opacity) {\n          this.shadowLayer.style.opacity = 0;\n        }\n      }\n\n      if (transform) {\n        container.style[transform] = 'translate3d(' + state.x + 'px, ' + state.y + 'px, 0px)';\n        return;\n      }\n\n      // respect old-fashioned browsers\n      container.style.left = this.state.x;\n      container.style.top = this.state.y;\n    }\n\n    /**\n     * calculateVelocity\n     * Calculate interaction velocity\n     */\n\n  }, {\n    key: 'calculateVelocity',\n    value: function calculateVelocity() {\n      var timeCapsule = this.timeCapsule;\n      var state = this.state;\n\n      var firstPoint = timeCapsule[0];\n      var lastPoint = timeCapsule[timeCapsule.length - 1];\n\n      var xOffset = lastPoint.x - firstPoint.x;\n      var yOffset = lastPoint.y - firstPoint.y;\n      var timeOffset = lastPoint.time - firstPoint.time;\n\n      var timePerPoint = timeOffset / this.timeCapsule.length;\n\n      state.velocityX = xOffset / timePerPoint || 0;\n      state.velocityY = yOffset / timePerPoint || 0;\n\n      if (NODE_ENV === 'development') {\n        this.momentumLayerX.style.transform = 'scaleX(' + state.velocityX / 30 + ')';\n        this.momentumLayerY.style.transform = 'scaleY(' + state.velocityY / 30 + ')';\n      }\n    }\n\n    /**\n     * releaseVelocity\n     * Animate layer, based on current velocity\n     */\n\n  }, {\n    key: 'releaseVelocity',\n    value: function releaseVelocity() {\n      var _this = this;\n\n      var state = this.state;\n      var options = this.parent.options;\n\n      var speedThreshold = 0.3;\n      var framesX = 0;\n      var framesY = 0;\n      var framesDefault = 350 / (1000 / 60); // used then both bounds have been overscrolled\n      var distanceX = 0;\n      var distanceY = 0;\n      var i = 1;\n\n      if (state.overscrollX && state.overscrollY) {\n        return this._animate({\n          distanceX: -state.overscrollX || 0,\n          distanceY: -state.overscrollY || 0,\n          time: 350\n        });\n      }\n\n      // calculate how much frames needs to impulse for go out\n      if (state.overscrollX) {\n        distanceX = -state.overscrollX;\n      } else if (state.velocityX && Math.abs(state.velocityX) > speedThreshold) {\n        framesX = Math.abs(Math.ceil(Math.log(speedThreshold / Math.abs(state.velocityX)) / Math.log(options.friction)));\n        while (i <= framesX) {\n          distanceX += state.velocityX * Math.pow(options.friction, i);\n          i++;\n        }\n      }\n\n      if (state.overscrollY) {\n        distanceY = -state.overscrollY;\n      } else if (state.velocityY && Math.abs(state.velocityY) > speedThreshold) {\n        framesY = Math.abs(Math.ceil(Math.log(speedThreshold / Math.abs(state.velocityY)) / Math.log(options.friction)));\n        i = 1;\n        while (i <= framesY) {\n          distanceY += state.velocityY * Math.pow(options.friction, i);\n          i++;\n        }\n      }\n\n      var frames = Math.abs(framesDefault, framesY, framesX);\n\n      this._animate({\n        distanceX: distanceX, distanceY: distanceY, frames: frames,\n        callback: function callback() {\n          // check if destination points makes us to feel little bit overscrolled.\n          if (state.overscrollX || state.overscrollY) {\n            return _this._animate({\n              distanceX: -state.overscrollX || 0,\n              distanceY: -state.overscrollY || 0,\n              time: 350\n            });\n          }\n        }\n      });\n    }\n\n    /**\n     * _animate\n     * Internal function to provide flexible api for animations. Used as internal method.\n     * @param  {Object} option\n     */\n\n  }, {\n    key: '_animate',\n    value: function _animate(_ref) {\n      var _this2 = this;\n\n      var distanceX = _ref.distanceX;\n      var distanceY = _ref.distanceY;\n      var easing = _ref.easing;\n      var frames = _ref.frames;\n      var time = _ref.time;\n      var callback = _ref.callback;\n      var state = this.state;\n\n      var startX = state.currentX;\n      var startY = state.currentY;\n      var currentFrame = 0;\n\n      if (!frames && time) {\n        frames = time / (1000 / 60);\n      }\n\n      if (!easing) {\n        easing = _easings.inertia;\n      }\n\n      state.isAnimated = true;\n\n      var tick = function tick() {\n        if (!state.isAnimated) {\n          return;\n        }\n\n        state.currentX = easing(currentFrame, startX, distanceX, frames);\n        state.currentY = easing(currentFrame, startY, distanceY, frames);\n\n        _this2.renderPosition();\n\n        currentFrame++;\n        if (currentFrame < frames) {\n          (0, _fps.write)(tick);\n        } else {\n          state.isAnimated = false;\n          if (typeof callback === 'function') {\n            callback();\n          }\n        }\n      };\n\n      (0, _fps.write)(tick);\n    }\n\n    /**\n     * overscrollReducer\n     * Reduce ammount of overscroll\n     * @param {Number} value - ammout of overscroll\n     * @return {Number} result - reduced ammount\n     */\n\n  }, {\n    key: 'overscrollReducer',\n    value: function overscrollReducer(value) {\n      var direction = value > 0 ? 1 : -1;\n      var i = Math.abs(value);\n      var results = 0;\n      while (i > 0) {\n        results += 1 / Math.pow(1.0035, i) * direction;\n        i--;\n      }\n\n      return results;\n    }\n\n    /**\n     * subscribe\n     * Subsribe to pointer events\n     */\n\n  }, {\n    key: 'subscribe',\n    value: function subscribe() {\n      this.processInteraction = this.processInteraction.bind(this);\n      this.parent.attach('start move end', this.processInteraction);\n    }\n\n    /**\n     * subscribe\n     * Unsubscribe from anything\n     */\n\n  }, {\n    key: 'unsubscribe',\n    value: function unsubscribe() {\n      this.parent.detach('start move end', this.processInteraction);\n    }\n\n    /**\n     * refresh\n     * Refresh component data\n     */\n\n  }, {\n    key: 'refresh',\n    value: function refresh() {\n      var state = this.state;\n      var container = this.container;\n\n      state.width = container.offsetWidth;\n      state.height = container.offsetHeight;\n\n      if (NODE_ENV === 'development') {\n        this.shadowLayer.style.width = state.width;\n        this.shadowLayer.style.height = state.height;\n      }\n    }\n\n    /**\n     * destroy\n     * destroy function\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.unsubscribe();\n\n      if (NODE_ENV === 'development') {\n        this.parent.container.removeChild(this.shadowLayer);\n        this.parent.container.removeChild(this.momentumLayerX);\n        this.parent.container.removeChild(this.momentumLayerY);\n      }\n    }\n  }]);\n\n  return RenderLayer;\n}();\n\nexports.default = RenderLayer;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./components/RenderLayer.js\n ** module id = 4\n ** module chunks = 0\n **/","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Easings collection\n */\n\n/**\n * Inertia easing\n * @param {Number} currentFrame\n * @param {Number} currentValue\n * @param {Number} ammountOfChange\n * @param {Number} totalFrames\n */\nvar inertia = function inertia(t, b, c, d) {\n  return c * ((t = t / d - 1) * t * t + 1) + b;\n};\n\nexports.inertia = inertia;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./libs/easings.js\n ** module id = 5\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = {\n  eventType: undefined, // what event type will be used. undefined = autodetect\n  'document': document, // the bottom most DOM element used for \"move\" and \"end\" events\n  preventDefault: true,\n\n  // scrolling\n  allowOverscroll: true,\n  scrollY: true,\n  scrollX: true,\n\n  // momentum\n  friction: 0.92,\n\n  // events\n  onReady: undefined\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./iscroll.options.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\n * Part, detects environment, supports, etc\n *\n */\n'use strict';\n\n/**\n * detectVendorPrefix\n * Browser vendor, used to apply CSS properties\n * @param {Object} detects - object to write detected data\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar detectVendorPrefix = function detectVendorPrefix(detects) {\n  var elementStyle = document.createElement('div').style;\n  var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'];\n  var vendor = false;\n\n  for (var i = 0, l = vendors.length; i < l; i++) {\n    if (vendors[i] + 'ransform' in elementStyle) {\n      vendor = vendors[i].substr(0, vendors[i].length - 1);\n      break;\n    }\n  }\n\n  detects.vendor = vendor;\n};\n\n/**\n * prefixCSSProperty\n * If needed prefix the CSS property with the vendor specific version\n * @param {string}   style - property to prefix\n * @param {Object} detects - object to write detected data\n */\nvar prefixCSSProperty = function prefixCSSProperty(style, detects) {\n  var vendor = detects.vendor;\n\n  if (vendor === false) {\n    return false;\n  }\n\n  var elementStyle = document.createElement('div').style;\n  style = vendor === '' ? style : vendor + style.charAt(0).toUpperCase() + style.substr(1);\n  return style in elementStyle && style;\n};\n\n/**\n * detectPointerEvents\n * Find what kind of events supports on client\n * @param {Object} detects - object to write detected data\n */\nvar detectPointerEvents = function detectPointerEvents(detects) {\n\n  Object.assign(detects, {\n    hasPointerEvents: !!window.navigator.pointerEnabled,\n    hasMSpointerEvents: !!window.navigator.msPointerEnabled,\n\n    // we are going to use user agent spoofing to prevent touch events on desktop. TODO: can it be done w/o spoofing?\n    useTouchEvents: 'ontouchstart' in window && /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(window.navigator.userAgent)\n  });\n\n  detects.useMouseEvents = !detects.hasPointerEvents && !detects.hasMSpointerEvents && !detects.useTouchEvents;\n};\n\n/**\n * apply\n * Extend object with calculated client data\n * @param {object} IscrollPrototype - target object\n */\n\nexports.default = function (IscrollPrototype) {\n  IscrollPrototype.detects = {};\n  IscrollPrototype.styles = {};\n  var detects = IscrollPrototype.detects;\n  var styles = IscrollPrototype.styles;\n\n  // run detects;\n\n  detectPointerEvents(detects);\n  detectVendorPrefix(detects);\n\n  // run style prefixes (#should move out of here soon)\n  Object.assign(styles, {\n    transform: prefixCSSProperty('transform', detects),\n    transitionDuration: prefixCSSProperty('transitionDuration', detects)\n  });\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./iscroll.detects.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":""}