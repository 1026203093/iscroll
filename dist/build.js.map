{"version":3,"sources":["webpack:///build.js","webpack:///webpack/bootstrap 8e9e6e9868299bb060ae","webpack:///./iscroll.js","webpack:///./mixins/EventEmitter.js","webpack:///./mixins/EventProcessor.js","webpack:///./libs/fps.js","webpack:///./iscroll.options.js","webpack:///./iscroll.detects.js","webpack:///./dev/StatePanel.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","_EventEmitter","_EventEmitter2","_EventProcessor","_EventProcessor2","Iscroll","element","options","arguments","undefined","this","jquery","document","querySelector","container","assign","state","LOOP","POINTS","apply","ready","emit","value","destructor","off","extend","window","_typeof","Symbol","constructor","type","_customEvents","slice","attach","cb","push","attachOnce","callback","detach","filter","item","on","context","_events","addEventListener","eventArr","removeEventListener","splice","_fps","EVENT_TYPE","pointer","start","move","end","cancel","MSPointer","touch","mouse","listOfInternalEvents","EventHandlingModule","handleEvent","e","eventType","_eventStart","_eventMove","_eventEnd","transitionEnd","_eventTransitionEnd","_eventResize","preventDefault","events","targetTouches","x","y","l","identifier","pageX","pageY","phase","initiated","startX","startY","deltaX","deltaY","startTime","Date","now","_renderLoop","changedTouches","_updatePoint","clearTimeout","_resizeTimeout","setTimeout","refresh","bind","point","currentTime","xd","yd","distance","Math","sqrt","distanceX","distanceY","theta","atan2","PI","pointCount","read","assignEventsFromOptions","_ref","forEach","eventName","IscrollInstance","detects","hasPointerEvents","hasMSpointerEvents","useTouchEvents","IscrollPrototype","vendors","request","requestAnimationFrame","cancelAnimationFrame","lastTime","readers","writers","currTime","getTime","timeToCall","max","fn","write","throttle","raf","args","loop","t","onReady","detectVendorPrefix","elementStyle","createElement","style","vendor","substr","detectTransitionEnd","types","","webkit","Moz","O","ms","prefixCSSProperty","charAt","toUpperCase","detectPointerEvents","navigator","pointerEnabled","msPointerEnabled","test","userAgent","useMouseEvents","styles","transform","transitionDuration","tick","newstring","JSON","stringify","oldstring","stats","innerHTML","position","top","right","padding","background","body","appendChild"],"mappings":"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","file":"build.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * iScroll by Matteo \"Cubiq\" Spinelli ~ http://cubiq.org ~ Released under MIT license\n\t */\n\t'use strict';\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tvar _EventEmitter = __webpack_require__(1);\n\t\n\tvar _EventEmitter2 = _interopRequireDefault(_EventEmitter);\n\t\n\tvar _EventProcessor = __webpack_require__(2);\n\t\n\tvar _EventProcessor2 = _interopRequireDefault(_EventProcessor);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tif (false) {\n\t  var _debug = require('./iscroll.debug.js')('iscroll.js');\n\t  window.debug.enable('iscroll*');\n\t}\n\t\n\tvar Iscroll = (function () {\n\t  function Iscroll(element) {\n\t    var _this = this;\n\t\n\t    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    _classCallCheck(this, Iscroll);\n\t\n\t\n\t\n\t    // if jquery element\n\t    if (element.jquery) {\n\t      element = element[0];\n\t    }\n\t\n\t    // if selector\n\t    if (typeof element === 'string') {\n\t      element = document.querySelector(element);\n\t    }\n\t\n\t    // if still no element - sorry\n\t    if (!element) {\n\t      throw 'Element is not defined!';\n\t    }\n\t\n\t    this.container = element;\n\t    this.options = Object.assign({}, __webpack_require__(4), options);\n\t    this.state = {\n\t      LOOP: false,\n\t      POINTS: []\n\t    };\n\t\n\t    // EXTENDS\n\t    __webpack_require__(5).default(this); // can be moved out of constructor, due perfomance reasons\n\t    _EventEmitter2.default.apply(this);\n\t    _EventProcessor2.default.apply(this);\n\t\n\t    this.state.ready = true;\n\t    this.emit('onReady');\n\t\n\t    // #DEV - ADDITIONAL MODULES\n\t    // if (NODE_ENV === 'development') {\n\t    // State display panel\n\t    __webpack_require__(6).default(this);\n\t    // }\n\t\n\t    // #DEV - HOT MODULE REPLACEMENT FOR EXTENDS\n\t    if (false) {\n\t      module.hot.accept(['./iscroll.detects.js', './mixins/EventEmitter.js', './mixins/EventProcessor.js'], function () {\n\t        _this.off();\n\t        require('./iscroll.detects.js').default(_this); // can be moved out of constructor, due perfomance reasons\n\t\n\t        var EventEmitter = require('./mixins/EventEmitter.js').default;\n\t        var EventProcessor = require('./mixins/EventProcessor.js').default;\n\t\n\t        EventEmitter.apply(_this);\n\t        EventProcessor.apply(_this);\n\t        EventEmitter.extend(Iscroll.prototype);\n\t        EventProcessor.extend(Iscroll.prototype);\n\t      });\n\t    }\n\t  }\n\t\n\t  // return all DOM to initial state, clean up after meal\n\t\n\t  _createClass(Iscroll, [{\n\t    key: 'destructor',\n\t    value: function destructor() {}\n\t\n\t    // force update state\n\t\n\t  }, {\n\t    key: 'update',\n\t    value: function update() {}\n\t  }, {\n\t    key: 'destroy',\n\t    value: function destroy() {\n\t      this.destructor();\n\t      this.off();\n\t    }\n\t  }]);\n\t\n\t  return Iscroll;\n\t})();\n\t\n\t_EventEmitter2.default.extend(Iscroll.prototype);\n\t_EventProcessor2.default.extend(Iscroll.prototype);\n\t\n\twindow.Iscroll = Iscroll;\n\tmodule.exports = Iscroll;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _typeof(obj) { return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }\n\t\n\t/**\n\t * Mixins provides methods used for event manipulating. \n\t *\n\t */\n\t\n\t/**\n\t * emit\n\t * Custom event emitter\n\t * @param {String}  type\n\t * @param {Object}  point\n\t */\n\tfunction emit(type) {\n\t  if (!this._customEvents[type]) {\n\t    return;\n\t  }\n\t\n\t  var i = this._customEvents[type].length;\n\t\n\t  while (i--) {\n\t    this._customEvents[type][i].apply(this, [].slice.call(arguments, 1));\n\t  }\n\t}\n\t\n\t/**\n\t * attach\n\t * Attach a custom event\n\t * @param {String}  type\n\t * @param {Function}  fn\n\t */\n\tfunction attach(type, cb) {\n\t  if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {\n\t    for (var i in type) {\n\t      this.attach(i, type[i]);\n\t    }\n\t\n\t    return;\n\t  }\n\t\n\t  if (!this._customEvents[type]) {\n\t    this._customEvents[type] = [];\n\t  }\n\t\n\t  this._customEvents[type].push(cb);\n\t}\n\t\n\t/**\n\t * attach\n\t * Attach a custom event\n\t * @param {String}  type\n\t * @param {Function}  fn\n\t */\n\tfunction attachOnce(type, cb) {\n\t\n\t  var callback = function callback() {\n\t    cb();\n\t    this.detach(type, callback);\n\t  };\n\t  this.attach(type, callback);\n\t}\n\t\n\t/**\n\t * detach\n\t * Detach a custom event\n\t * @param {String}  type\n\t * @param {Function}  fn\n\t */\n\tfunction detach(type, cb) {\n\t  if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {\n\t    for (var i in type) {\n\t      this.detach(i, type[i]);\n\t    }\n\t    return;\n\t  }\n\t\n\t  if (!this._customEvents[type]) {\n\t    return;\n\t  }\n\t\n\t  if (!cb) {\n\t    this._customEvents[type] = [];\n\t  } else {\n\t    this._customEvents[type].filter(function (item) {\n\t      return item !== cb;\n\t    });\n\t  }\n\t}\n\t\n\t/**\n\t * on\n\t * Attach an event listener\n\t * @param {string}      type - event type name\n\t * @param {HTMLElement} [context=this.container]\n\t * @param {Function}    [cb=this]\n\t */\n\tfunction on(type, context, cb) {\n\t  if (!this._events[type]) {\n\t    this._events[type] = [];\n\t  }\n\t\n\t  cb = cb || this;\n\t  context = context || this.container;\n\t\n\t  this._events[type].push({ cb: cb, context: context });\n\t\n\t  context.addEventListener(type, cb, false);\n\t}\n\t\n\t/**\n\t * off\n\t * Release an event listener. If type is undefined remove all registered events\n\t * @param {string}      [type] - event type name\n\t * @param {HTMLElement} [context=this.container]\n\t * @param {Function}    [cb=this] - callback\n\t */\n\tfunction off(type, context, cb) {\n\t  var i;\n\t\n\t  // if called without parameters remove all events\n\t  if (!type) {\n\t    for (i in this._events) {\n\t      this.off(i, this._events[i].context, this._events[i].cb);\n\t    }\n\t\n\t    return;\n\t  }\n\t\n\t  if (!this._events[type]) {\n\t    return;\n\t  }\n\t\n\t  cb = cb || this;\n\t  context = context || this.container;\n\t\n\t  // we work on a clone of the original array\n\t  var eventArr = this._events[type].slice(0);\n\t\n\t  for (i = eventArr.length; i--;) {\n\t    if (eventArr[i].cb === cb && eventArr[i].context === context) {\n\t      context.removeEventListener(type, cb, false);\n\t      this._events[type].splice(i, 1);\n\t    }\n\t  }\n\t\n\t  if (!this._events[type].length) {\n\t    delete this._events[type];\n\t  }\n\t}\n\t\n\texports.default = {\n\t\n\t  /**\n\t   * apply\n\t   * Apply event emitter to object\n\t   * @param {Object} object - target object\n\t   */\n\t\n\t  apply: function apply(obj) {\n\t    obj._events = {}; // holds all the Default registered events\n\t    obj._customEvents = {}; // holds all iScroll specific events\n\t  },\n\t\n\t  /**\n\t   * extend\n\t   * Extend object (for prototypes)\n\t   * @param {Object} object - target object\n\t   */\n\t  extend: function extend(obj) {\n\t    Object.assign(obj, { attach: attach, attachOnce: attachOnce, detach: detach, emit: emit, on: on, off: off });\n\t  }\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Mixins provides methods used for event dispatching\n\t *\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _fps = __webpack_require__(3);\n\t\n\t/**\n\t * List all known pointer events\n\t * @const {Object}\n\t */\n\tvar EVENT_TYPE = {\n\t  pointer: {\n\t    start: 'pointerdown',\n\t    move: 'pointermove',\n\t    end: 'pointerup',\n\t    cancel: 'pointercancel'\n\t  },\n\t  MSPointer: {\n\t    start: 'MSPointerDown',\n\t    move: 'MSPointerMove',\n\t    end: 'MSPointerUp',\n\t    cancel: 'MSPointerCancel'\n\t  },\n\t  touch: {\n\t    start: 'touchstart',\n\t    move: 'touchmove',\n\t    end: 'touchend',\n\t    cancel: 'touchcancel'\n\t  },\n\t  mouse: {\n\t    start: 'mousedown',\n\t    move: 'mousemove',\n\t    end: 'mouseup',\n\t    cancel: 'mousecancel'\n\t  }\n\t};\n\t\n\t/**\n\t * List all confogurable events\n\t * @const {Array}\n\t */\n\tvar listOfInternalEvents = [\n\t// basic events\n\t'onReady', 'onRefresh', 'onDestroy',\n\t\n\t// declared on iscroll5\n\t'beforeScrollStart', 'scrollCancel', 'scrollStart', 'scroll', 'scrollEnd', 'flick', 'zoomStart', 'zoomEnd'];\n\t\n\tvar EventHandlingModule = {\n\t  /**\n\t   * handleEvent\n\t   * Global event proxy\n\t   * @param {Object} e - event object\n\t   */\n\t\n\t  handleEvent: function handleEvent(e) {\n\t\n\t    switch (e.type) {\n\t      case this.eventType.start:\n\t        this._eventStart(e);\n\t        break;\n\t      case this.eventType.move:\n\t        this._eventMove(e);\n\t        break;\n\t      case this.eventType.end:\n\t      case this.eventType.cancel:\n\t        this._eventEnd(e);\n\t        break;\n\t      case this.eventType.transitionEnd:\n\t        this._eventTransitionEnd(e);\n\t        break;\n\t      case 'orientationchange':\n\t      case 'resize':\n\t        this._eventResize(e);\n\t        break;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * _eventStart\n\t   * Initial user interactions phase\n\t   * @param {Object} e - event object\n\t   */\n\t  _eventStart: function _eventStart(e) {\n\t    if (this.options.preventDefault) {\n\t      e.preventDefault();\n\t    }\n\t\n\t    var events = e.targetTouches || [e];\n\t    var id = undefined,\n\t        x = undefined,\n\t        y = undefined,\n\t        i = undefined,\n\t        l = undefined;\n\t\n\t    for (i = 0, l = events.length; i < l; i++) {\n\t\n\t      id = events[i].identifier || 0;\n\t      x = events[i].pageX;\n\t      y = events[i].pageY;\n\t\n\t      this.state.POINTS[id] = {\n\t        // instance: this, // disabled, for circular json reasons\n\t        id: id + '',\n\t        phase: 'start',\n\t        initiated: false,\n\t        x: x,\n\t        y: y,\n\t        startX: x,\n\t        startY: y,\n\t        deltaX: 0,\n\t        deltaY: 0,\n\t        startTime: Date.now()\n\t      };\n\t    }\n\t\n\t    // start the rAF loop\n\t    if (!this.state.LOOP) {\n\t      this._renderLoop();\n\t    }\n\t\n\t    // start listening to 'move' and 'end' events only when the drag session is initiated\n\t    // on desktop this should prevent useless mousemove events\n\t    this.on(this.eventType.move, this.options.document);\n\t    this.on(this.eventType.end, this.options.document);\n\t  },\n\t\n\t  /**\n\t   * _eventMove\n\t   * Proceed each pointer move event\n\t   * @param {Object} e - event object\n\t   */\n\t  _eventMove: function _eventMove(e) {\n\t    var events = e.changedTouches || [e];\n\t    var POINTS = this.state.POINTS;\n\t\n\t    var id = undefined,\n\t        i = undefined;\n\t\n\t    for (i = events.length; i--;) {\n\t      id = events[i].identifier || 0;\n\t\n\t      if (POINTS[id] && POINTS[id].initiated) {\n\t        POINTS[id] = this._updatePoint(POINTS[id], e);\n\t        POINTS[id].phase = 'move';\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * _eventMove\n\t   * Proceed last interaction event\n\t   * @param {Object} e - event object\n\t   */\n\t  _eventEnd: function _eventEnd(e) {\n\t    var events = e.changedTouches || [e];\n\t    var POINTS = this.state.POINTS;\n\t\n\t    var id = undefined,\n\t        i = undefined;\n\t\n\t    for (i = events.length; i--;) {\n\t      id = events[i].identifier || 0;\n\t\n\t      if (POINTS[id] && POINTS[id].initiated) {\n\t        POINTS[id] = this._updatePoint(POINTS[id], e);\n\t        POINTS[id].phase = 'end';\n\t      }\n\t    }\n\t\n\t    this.off(this.eventType.move, this.options.document);\n\t    this.off(this.eventType.end, this.options.document);\n\t  },\n\t\n\t  /**\n\t   * _eventResize\n\t   * Proceed viewport resize event\n\t   * @param {Object} e - event object\n\t   */\n\t  _eventResize: function _eventResize(e) {\n\t    clearTimeout(this._resizeTimeout);\n\t\n\t    // if we resize before the script has been initialized\n\t    if (!this.ready) {\n\t      return this.attachOnce('onReady', this._eventResize.bind(this, e));\n\t    }\n\t\n\t    // defer the resize event to spare resources\n\t    this._resizeTimeout = setTimeout(this.refresh.bind(this), 100);\n\t  },\n\t\n\t  /**\n\t   * _updatePoint\n\t   * ....\n\t   * @param {Object} point - .....\n\t   * @param {Object} e - event object\n\t   */\n\t  _updatePoint: function _updatePoint(point, e) {\n\t    point.currentTime = Date.now();\n\t\n\t    // distance travelled since last event\n\t    point.deltaX = point.x - e.pageX;\n\t    point.deltaY = point.y - e.pageY;\n\t\n\t    // update current position\n\t    point.x = e.pageX;\n\t    point.y = e.pageY;\n\t\n\t    // distance from start\n\t    var xd = point.startX - point.x;\n\t    var yd = point.startY - point.y;\n\t    point.distance = Math.sqrt(xd * xd + yd * yd);\n\t    point.distanceX = xd;\n\t    point.distanceY = yd;\n\t\n\t    // angle from start (hence direction) 0=right, counter clockwise\n\t    var theta = Math.atan2(yd, -xd);\n\t    if (theta < 0) {\n\t      theta += 2 * Math.PI;\n\t    }\n\t    //theta *= (180 / Math.PI);   // convert to degrees\n\t    point.theta = theta;\n\t\n\t    return point;\n\t  },\n\t\n\t  /**\n\t   * _renderLoop\n\t   * One frame in the requestAnimationFrame loop\n\t   */\n\t  _renderLoop: function _renderLoop() {\n\t    var pointCount = 0;\n\t    var POINTS = this.state.POINTS;\n\t\n\t    for (var id in POINTS) {\n\t      var point = POINTS[id];\n\t\n\t      switch (point.phase) {\n\t        case 'move':\n\t          this.emit('move', point);\n\t          break;\n\t        case 'start':\n\t          if (!point.initiated) {\n\t            point.initiated = true;\n\t            this.emit('start', point);\n\t          }\n\t          break;\n\t        case 'end':\n\t          point.initiated = false;\n\t          this.emit('end', point);\n\t          delete POINTS[id];\n\t          break;\n\t      }\n\t\n\t      pointCount++;\n\t    }\n\t\n\t    // keep animating until there are points in the POINTS object\n\t    this.state.LOOP = !!pointCount;\n\t\n\t    if (this.state.LOOP) {\n\t      (0, _fps.read)(this._renderLoop.bind(this));\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * assignEventsFromOptions\n\t * Extend object with configured event data\n\t * @param {Object} IscrollInstance - instance options\n\t */\n\tvar assignEventsFromOptions = function assignEventsFromOptions(_ref) {\n\t  var options = _ref.options;\n\t  var attach = _ref.attach;\n\t\n\t  listOfInternalEvents.forEach(function (eventName) {\n\t    if (!options[eventName]) {\n\t      return;\n\t    }\n\t\n\t    attach(eventName, options[eventName]);\n\t  });\n\t};\n\t\n\texports.default = {\n\t\n\t  /**\n\t   * apply\n\t   * Extend object with configured event data\n\t   * @param {object} type - target object\n\t   */\n\t\n\t  apply: function apply(IscrollInstance) {\n\t    var options = IscrollInstance.options;\n\t    var detects = IscrollInstance.detects;\n\t\n\t    // choose the appropriate event type to use, it can also be forced via options\n\t\n\t    if (options.eventType) {\n\t      IscrollInstance.eventType = EVENT_TYPE[options.eventType];\n\t    } else if (detects.hasPointerEvents) {\n\t      IscrollInstance.eventType = EVENT_TYPE.pointer;\n\t    } else if (detects.hasMSpointerEvents) {\n\t      IscrollInstance.eventType = EVENT_TYPE.MSPointer;\n\t    } else if (detects.useTouchEvents) {\n\t      IscrollInstance.eventType = EVENT_TYPE.touch;\n\t    } else {\n\t      IscrollInstance.eventType = EVENT_TYPE.mouse;\n\t    }\n\t\n\t    // bind basic events\n\t    IscrollInstance.on('orientationchange', window);\n\t    IscrollInstance.on('resize', window);\n\t    IscrollInstance.on(IscrollInstance.eventType.start);\n\t    IscrollInstance.on(IscrollInstance.eventType.transitionEnd);\n\t\n\t    // setup events from user config\n\t    assignEventsFromOptions(IscrollInstance);\n\t  },\n\t\n\t  /**\n\t   * extend\n\t   * Extend object (for prototypes)\n\t   * @param {Object} object - target object\n\t   */\n\t  extend: function extend(IscrollPrototype) {\n\t    Object.assign(IscrollPrototype, EventHandlingModule);\n\t  }\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar vendors = ['ms', 'moz', 'webkit', 'o'];\n\t\n\tvar request = window.requestAnimationFrame;\n\tvar cancel = window.cancelAnimationFrame;\n\t\n\tvar lastTime = 0;\n\tvar readers = [];\n\tvar writers = [];\n\tfor (var x = 0; x < vendors.length && !request; ++x) {\n\t  exports.request = request = window[vendors[x] + 'RequestAnimationFrame'];\n\t  exports.cancel = cancel = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n\t}\n\t\n\tif (!request) {\n\t  exports.request = request = function (callback) {\n\t    var currTime = new Date().getTime();\n\t    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t    var id = setTimeout(function () {\n\t      callback(currTime + timeToCall);\n\t    }, timeToCall);\n\t\n\t    lastTime = currTime + timeToCall;\n\t    return id;\n\t  };\n\t}\n\t\n\tif (!cancel) {\n\t  exports.cancel = cancel = function (id) {\n\t    clearTimeout(id);\n\t  };\n\t}\n\t\n\tvar read = function read(fn) {\n\t  readers.push(fn);\n\t};\n\t\n\tvar write = function write(fn) {\n\t  writers.push(fn);\n\t};\n\t\n\tvar throttle = function throttle(fn) {\n\t  var raf = undefined;\n\t\n\t  return function requestAnimationFrameThrottler() {\n\t    var args = arguments;\n\t    if (raf) {\n\t      cancel(raf);\n\t    }\n\t\n\t    raf = read(function requestAnimationFrameHandler() {\n\t      raf = false;\n\t      fn.apply(this, args);\n\t    });\n\t  };\n\t};\n\t\n\tvar loop = function loop() {\n\t  var read = readers;\n\t  readers = [];\n\t  read.forEach(function (t) {\n\t    return t();\n\t  });\n\t\n\t  var write = writers;\n\t  writers = [];\n\t  write.forEach(function (t) {\n\t    return t();\n\t  });\n\t\n\t  request(loop, 'loop set');\n\t};\n\t\n\trequest(loop, 'loop set');\n\t\n\texports.request = request;\n\texports.cancel = cancel;\n\texports.read = read;\n\texports.write = write;\n\texports.throttle = throttle;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = {\n\t  eventType: undefined, // what event type will be used. undefined = autodetect\n\t  'document': document, // the bottom most DOM element used for \"move\" and \"end\" events\n\t  preventDefault: true,\n\t  onReady: undefined\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Part, detects environment, supports, etc\n\t *\n\t */\n\t'use strict';\n\t\n\t/**\n\t * detectVendorPrefix\n\t * Browser vendor, used to apply CSS properties\n\t * @param {Object} detects - object to write detected data\n\t */\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar detectVendorPrefix = function detectVendorPrefix(detects) {\n\t  var elementStyle = document.createElement('div').style;\n\t  var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'];\n\t  var vendor = false;\n\t\n\t  for (var i = 0, l = vendors.length; i < l; i++) {\n\t    if (vendors[i] + 'ransform' in elementStyle) {\n\t      vendor = vendors[i].substr(0, vendors[i].length - 1);\n\t      break;\n\t    }\n\t  }\n\t\n\t  detects.vendor = vendor;\n\t};\n\t\n\t/**\n\t * detectTransitionEnd\n\t * Find the transitionEnd event based on the vendor, there's no pattern so\n\t * we have to use a function\n\t * @param {Object} detects - object to write detected data\n\t */\n\tvar detectTransitionEnd = function detectTransitionEnd(detects) {\n\t  var types = {\n\t    '': 'transitionend',\n\t    'webkit': 'webkitTransitionEnd',\n\t    'Moz': 'transitionend',\n\t    'O': 'oTransitionEnd',\n\t    'ms': 'MSTransitionEnd'\n\t  };\n\t\n\t  detects.vendor = types[detects.vendor] || false;\n\t};\n\t\n\t/**\n\t * prefixCSSProperty\n\t * If needed prefix the CSS property with the vendor specific version\n\t * @param {string}   style - property to prefix\n\t * @param {Object} detects - object to write detected data\n\t */\n\tvar prefixCSSProperty = function prefixCSSProperty(style, detects) {\n\t  var vendor = detects.vendor;\n\t\n\t  if (!vendor) {\n\t    return false;\n\t  }\n\t\n\t  var elementStyle = document.createElement('div').style;\n\t  style = vendor === '' ? style : vendor + style.charAt(0).toUpperCase() + style.substr(1);\n\t  return style in elementStyle && style;\n\t};\n\t\n\t/**\n\t * detectPointerEvents\n\t * Find what kind of events supports on client\n\t * @param {Object} detects - object to write detected data\n\t */\n\tvar detectPointerEvents = function detectPointerEvents(detects) {\n\t\n\t  Object.assign(detects, {\n\t    hasPointerEvents: !!window.navigator.pointerEnabled,\n\t    hasMSpointerEvents: !!window.navigator.msPointerEnabled,\n\t    // we are going to use user agent spoofing to prevent touch events on desktop. TODO: can it be done w/o spoofing?\n\t    useTouchEvents: 'ontouchstart' in window && /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(window.navigator.userAgent)\n\t  });\n\t\n\t  detects.useMouseEvents = !detects.hasPointerEvents && !detects.hasMSpointerEvents && !detects.useTouchEvents;\n\t};\n\t\n\t/**\n\t * apply\n\t * Extend object with calculated client data\n\t * @param {object} IscrollPrototype - target object\n\t */\n\t\n\texports.default = function (IscrollPrototype) {\n\t  IscrollPrototype.detects = {};\n\t  IscrollPrototype.styles = {};\n\t  var detects = IscrollPrototype.detects;\n\t  var styles = IscrollPrototype.styles;\n\t\n\t  // run detects;\n\t\n\t  detectPointerEvents(detects);\n\t  detectVendorPrefix(detects);\n\t  detectTransitionEnd(detects);\n\t\n\t  // run style prefixes\n\t  Object.assign(styles, {\n\t    transform: prefixCSSProperty('transform', detects),\n\t    transitionDuration: prefixCSSProperty('transitionDuration', detects)\n\t  });\n\t};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _fps = __webpack_require__(3);\n\t\n\texports.default = function (IscrollInstance) {\n\t  var stats = document.createElement('div');\n\t  var oldstring = undefined,\n\t      newstring = undefined;\n\t\n\t  stats.style.position = 'fixed';\n\t  stats.style.top = 0;\n\t  stats.style.right = 0;\n\t  stats.style.padding = 10;\n\t  stats.style.background = 'red';\n\t  document.body.appendChild(stats);\n\t\n\t  function tick() {\n\t    newstring = JSON.stringify(IscrollInstance.state, null, 4);\n\t    if (oldstring !== newstring) {\n\t      oldstring = newstring;\n\t      stats.innerHTML = '<pre style=\"width:360px\">' + newstring + '</pre>';\n\t    }\n\t    (0, _fps.write)(tick);\n\t  }\n\t  (0, _fps.write)(tick);\n\t};\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** build.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 8e9e6e9868299bb060ae\n **/","/*!\n * iScroll by Matteo \"Cubiq\" Spinelli ~ http://cubiq.org ~ Released under MIT license\n */\n'use strict';\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _EventEmitter = require('./mixins/EventEmitter.js');\n\nvar _EventEmitter2 = _interopRequireDefault(_EventEmitter);\n\nvar _EventProcessor = require('./mixins/EventProcessor.js');\n\nvar _EventProcessor2 = _interopRequireDefault(_EventProcessor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nif (NODE_ENV === 'development') {\n  var _debug = require('./iscroll.debug.js')('iscroll.js');\n  window.debug.enable('iscroll*');\n}\n\nvar Iscroll = (function () {\n  function Iscroll(element) {\n    var _this = this;\n\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Iscroll);\n\n\n\n    // if jquery element\n    if (element.jquery) {\n      element = element[0];\n    }\n\n    // if selector\n    if (typeof element === 'string') {\n      element = document.querySelector(element);\n    }\n\n    // if still no element - sorry\n    if (!element) {\n      throw 'Element is not defined!';\n    }\n\n    this.container = element;\n    this.options = Object.assign({}, require('./iscroll.options.js'), options);\n    this.state = {\n      LOOP: false,\n      POINTS: []\n    };\n\n    // EXTENDS\n    require('./iscroll.detects.js').default(this); // can be moved out of constructor, due perfomance reasons\n    _EventEmitter2.default.apply(this);\n    _EventProcessor2.default.apply(this);\n\n    this.state.ready = true;\n    this.emit('onReady');\n\n    // #DEV - ADDITIONAL MODULES\n    // if (NODE_ENV === 'development') {\n    // State display panel\n    require('./dev/StatePanel.js').default(this);\n    // }\n\n    // #DEV - HOT MODULE REPLACEMENT FOR EXTENDS\n    if (module.hot) {\n      module.hot.accept(['./iscroll.detects.js', './mixins/EventEmitter.js', './mixins/EventProcessor.js'], function () {\n        _this.off();\n        require('./iscroll.detects.js').default(_this); // can be moved out of constructor, due perfomance reasons\n\n        var EventEmitter = require('./mixins/EventEmitter.js').default;\n        var EventProcessor = require('./mixins/EventProcessor.js').default;\n\n        EventEmitter.apply(_this);\n        EventProcessor.apply(_this);\n        EventEmitter.extend(Iscroll.prototype);\n        EventProcessor.extend(Iscroll.prototype);\n      });\n    }\n  }\n\n  // return all DOM to initial state, clean up after meal\n\n  _createClass(Iscroll, [{\n    key: 'destructor',\n    value: function destructor() {}\n\n    // force update state\n\n  }, {\n    key: 'update',\n    value: function update() {}\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.destructor();\n      this.off();\n    }\n  }]);\n\n  return Iscroll;\n})();\n\n_EventEmitter2.default.extend(Iscroll.prototype);\n_EventProcessor2.default.extend(Iscroll.prototype);\n\nwindow.Iscroll = Iscroll;\nmodule.exports = Iscroll;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./iscroll.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _typeof(obj) { return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }\n\n/**\n * Mixins provides methods used for event manipulating. \n *\n */\n\n/**\n * emit\n * Custom event emitter\n * @param {String}  type\n * @param {Object}  point\n */\nfunction emit(type) {\n  if (!this._customEvents[type]) {\n    return;\n  }\n\n  var i = this._customEvents[type].length;\n\n  while (i--) {\n    this._customEvents[type][i].apply(this, [].slice.call(arguments, 1));\n  }\n}\n\n/**\n * attach\n * Attach a custom event\n * @param {String}  type\n * @param {Function}  fn\n */\nfunction attach(type, cb) {\n  if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {\n    for (var i in type) {\n      this.attach(i, type[i]);\n    }\n\n    return;\n  }\n\n  if (!this._customEvents[type]) {\n    this._customEvents[type] = [];\n  }\n\n  this._customEvents[type].push(cb);\n}\n\n/**\n * attach\n * Attach a custom event\n * @param {String}  type\n * @param {Function}  fn\n */\nfunction attachOnce(type, cb) {\n\n  var callback = function callback() {\n    cb();\n    this.detach(type, callback);\n  };\n  this.attach(type, callback);\n}\n\n/**\n * detach\n * Detach a custom event\n * @param {String}  type\n * @param {Function}  fn\n */\nfunction detach(type, cb) {\n  if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {\n    for (var i in type) {\n      this.detach(i, type[i]);\n    }\n    return;\n  }\n\n  if (!this._customEvents[type]) {\n    return;\n  }\n\n  if (!cb) {\n    this._customEvents[type] = [];\n  } else {\n    this._customEvents[type].filter(function (item) {\n      return item !== cb;\n    });\n  }\n}\n\n/**\n * on\n * Attach an event listener\n * @param {string}      type - event type name\n * @param {HTMLElement} [context=this.container]\n * @param {Function}    [cb=this]\n */\nfunction on(type, context, cb) {\n  if (!this._events[type]) {\n    this._events[type] = [];\n  }\n\n  cb = cb || this;\n  context = context || this.container;\n\n  this._events[type].push({ cb: cb, context: context });\n\n  context.addEventListener(type, cb, false);\n}\n\n/**\n * off\n * Release an event listener. If type is undefined remove all registered events\n * @param {string}      [type] - event type name\n * @param {HTMLElement} [context=this.container]\n * @param {Function}    [cb=this] - callback\n */\nfunction off(type, context, cb) {\n  var i;\n\n  // if called without parameters remove all events\n  if (!type) {\n    for (i in this._events) {\n      this.off(i, this._events[i].context, this._events[i].cb);\n    }\n\n    return;\n  }\n\n  if (!this._events[type]) {\n    return;\n  }\n\n  cb = cb || this;\n  context = context || this.container;\n\n  // we work on a clone of the original array\n  var eventArr = this._events[type].slice(0);\n\n  for (i = eventArr.length; i--;) {\n    if (eventArr[i].cb === cb && eventArr[i].context === context) {\n      context.removeEventListener(type, cb, false);\n      this._events[type].splice(i, 1);\n    }\n  }\n\n  if (!this._events[type].length) {\n    delete this._events[type];\n  }\n}\n\nexports.default = {\n\n  /**\n   * apply\n   * Apply event emitter to object\n   * @param {Object} object - target object\n   */\n\n  apply: function apply(obj) {\n    obj._events = {}; // holds all the Default registered events\n    obj._customEvents = {}; // holds all iScroll specific events\n  },\n\n  /**\n   * extend\n   * Extend object (for prototypes)\n   * @param {Object} object - target object\n   */\n  extend: function extend(obj) {\n    Object.assign(obj, { attach: attach, attachOnce: attachOnce, detach: detach, emit: emit, on: on, off: off });\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mixins/EventEmitter.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * Mixins provides methods used for event dispatching\n *\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fps = require('../libs/fps.js');\n\n/**\n * List all known pointer events\n * @const {Object}\n */\nvar EVENT_TYPE = {\n  pointer: {\n    start: 'pointerdown',\n    move: 'pointermove',\n    end: 'pointerup',\n    cancel: 'pointercancel'\n  },\n  MSPointer: {\n    start: 'MSPointerDown',\n    move: 'MSPointerMove',\n    end: 'MSPointerUp',\n    cancel: 'MSPointerCancel'\n  },\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    end: 'touchend',\n    cancel: 'touchcancel'\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    end: 'mouseup',\n    cancel: 'mousecancel'\n  }\n};\n\n/**\n * List all confogurable events\n * @const {Array}\n */\nvar listOfInternalEvents = [\n// basic events\n'onReady', 'onRefresh', 'onDestroy',\n\n// declared on iscroll5\n'beforeScrollStart', 'scrollCancel', 'scrollStart', 'scroll', 'scrollEnd', 'flick', 'zoomStart', 'zoomEnd'];\n\nvar EventHandlingModule = {\n  /**\n   * handleEvent\n   * Global event proxy\n   * @param {Object} e - event object\n   */\n\n  handleEvent: function handleEvent(e) {\n\n    switch (e.type) {\n      case this.eventType.start:\n        this._eventStart(e);\n        break;\n      case this.eventType.move:\n        this._eventMove(e);\n        break;\n      case this.eventType.end:\n      case this.eventType.cancel:\n        this._eventEnd(e);\n        break;\n      case this.eventType.transitionEnd:\n        this._eventTransitionEnd(e);\n        break;\n      case 'orientationchange':\n      case 'resize':\n        this._eventResize(e);\n        break;\n    }\n  },\n\n  /**\n   * _eventStart\n   * Initial user interactions phase\n   * @param {Object} e - event object\n   */\n  _eventStart: function _eventStart(e) {\n    if (this.options.preventDefault) {\n      e.preventDefault();\n    }\n\n    var events = e.targetTouches || [e];\n    var id = undefined,\n        x = undefined,\n        y = undefined,\n        i = undefined,\n        l = undefined;\n\n    for (i = 0, l = events.length; i < l; i++) {\n\n      id = events[i].identifier || 0;\n      x = events[i].pageX;\n      y = events[i].pageY;\n\n      this.state.POINTS[id] = {\n        // instance: this, // disabled, for circular json reasons\n        id: id + '',\n        phase: 'start',\n        initiated: false,\n        x: x,\n        y: y,\n        startX: x,\n        startY: y,\n        deltaX: 0,\n        deltaY: 0,\n        startTime: Date.now()\n      };\n    }\n\n    // start the rAF loop\n    if (!this.state.LOOP) {\n      this._renderLoop();\n    }\n\n    // start listening to 'move' and 'end' events only when the drag session is initiated\n    // on desktop this should prevent useless mousemove events\n    this.on(this.eventType.move, this.options.document);\n    this.on(this.eventType.end, this.options.document);\n  },\n\n  /**\n   * _eventMove\n   * Proceed each pointer move event\n   * @param {Object} e - event object\n   */\n  _eventMove: function _eventMove(e) {\n    var events = e.changedTouches || [e];\n    var POINTS = this.state.POINTS;\n\n    var id = undefined,\n        i = undefined;\n\n    for (i = events.length; i--;) {\n      id = events[i].identifier || 0;\n\n      if (POINTS[id] && POINTS[id].initiated) {\n        POINTS[id] = this._updatePoint(POINTS[id], e);\n        POINTS[id].phase = 'move';\n      }\n    }\n  },\n\n  /**\n   * _eventMove\n   * Proceed last interaction event\n   * @param {Object} e - event object\n   */\n  _eventEnd: function _eventEnd(e) {\n    var events = e.changedTouches || [e];\n    var POINTS = this.state.POINTS;\n\n    var id = undefined,\n        i = undefined;\n\n    for (i = events.length; i--;) {\n      id = events[i].identifier || 0;\n\n      if (POINTS[id] && POINTS[id].initiated) {\n        POINTS[id] = this._updatePoint(POINTS[id], e);\n        POINTS[id].phase = 'end';\n      }\n    }\n\n    this.off(this.eventType.move, this.options.document);\n    this.off(this.eventType.end, this.options.document);\n  },\n\n  /**\n   * _eventResize\n   * Proceed viewport resize event\n   * @param {Object} e - event object\n   */\n  _eventResize: function _eventResize(e) {\n    clearTimeout(this._resizeTimeout);\n\n    // if we resize before the script has been initialized\n    if (!this.ready) {\n      return this.attachOnce('onReady', this._eventResize.bind(this, e));\n    }\n\n    // defer the resize event to spare resources\n    this._resizeTimeout = setTimeout(this.refresh.bind(this), 100);\n  },\n\n  /**\n   * _updatePoint\n   * ....\n   * @param {Object} point - .....\n   * @param {Object} e - event object\n   */\n  _updatePoint: function _updatePoint(point, e) {\n    point.currentTime = Date.now();\n\n    // distance travelled since last event\n    point.deltaX = point.x - e.pageX;\n    point.deltaY = point.y - e.pageY;\n\n    // update current position\n    point.x = e.pageX;\n    point.y = e.pageY;\n\n    // distance from start\n    var xd = point.startX - point.x;\n    var yd = point.startY - point.y;\n    point.distance = Math.sqrt(xd * xd + yd * yd);\n    point.distanceX = xd;\n    point.distanceY = yd;\n\n    // angle from start (hence direction) 0=right, counter clockwise\n    var theta = Math.atan2(yd, -xd);\n    if (theta < 0) {\n      theta += 2 * Math.PI;\n    }\n    //theta *= (180 / Math.PI);   // convert to degrees\n    point.theta = theta;\n\n    return point;\n  },\n\n  /**\n   * _renderLoop\n   * One frame in the requestAnimationFrame loop\n   */\n  _renderLoop: function _renderLoop() {\n    var pointCount = 0;\n    var POINTS = this.state.POINTS;\n\n    for (var id in POINTS) {\n      var point = POINTS[id];\n\n      switch (point.phase) {\n        case 'move':\n          this.emit('move', point);\n          break;\n        case 'start':\n          if (!point.initiated) {\n            point.initiated = true;\n            this.emit('start', point);\n          }\n          break;\n        case 'end':\n          point.initiated = false;\n          this.emit('end', point);\n          delete POINTS[id];\n          break;\n      }\n\n      pointCount++;\n    }\n\n    // keep animating until there are points in the POINTS object\n    this.state.LOOP = !!pointCount;\n\n    if (this.state.LOOP) {\n      (0, _fps.read)(this._renderLoop.bind(this));\n    }\n  }\n};\n\n/**\n * assignEventsFromOptions\n * Extend object with configured event data\n * @param {Object} IscrollInstance - instance options\n */\nvar assignEventsFromOptions = function assignEventsFromOptions(_ref) {\n  var options = _ref.options;\n  var attach = _ref.attach;\n\n  listOfInternalEvents.forEach(function (eventName) {\n    if (!options[eventName]) {\n      return;\n    }\n\n    attach(eventName, options[eventName]);\n  });\n};\n\nexports.default = {\n\n  /**\n   * apply\n   * Extend object with configured event data\n   * @param {object} type - target object\n   */\n\n  apply: function apply(IscrollInstance) {\n    var options = IscrollInstance.options;\n    var detects = IscrollInstance.detects;\n\n    // choose the appropriate event type to use, it can also be forced via options\n\n    if (options.eventType) {\n      IscrollInstance.eventType = EVENT_TYPE[options.eventType];\n    } else if (detects.hasPointerEvents) {\n      IscrollInstance.eventType = EVENT_TYPE.pointer;\n    } else if (detects.hasMSpointerEvents) {\n      IscrollInstance.eventType = EVENT_TYPE.MSPointer;\n    } else if (detects.useTouchEvents) {\n      IscrollInstance.eventType = EVENT_TYPE.touch;\n    } else {\n      IscrollInstance.eventType = EVENT_TYPE.mouse;\n    }\n\n    // bind basic events\n    IscrollInstance.on('orientationchange', window);\n    IscrollInstance.on('resize', window);\n    IscrollInstance.on(IscrollInstance.eventType.start);\n    IscrollInstance.on(IscrollInstance.eventType.transitionEnd);\n\n    // setup events from user config\n    assignEventsFromOptions(IscrollInstance);\n  },\n\n  /**\n   * extend\n   * Extend object (for prototypes)\n   * @param {Object} object - target object\n   */\n  extend: function extend(IscrollPrototype) {\n    Object.assign(IscrollPrototype, EventHandlingModule);\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mixins/EventProcessor.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar vendors = ['ms', 'moz', 'webkit', 'o'];\n\nvar request = window.requestAnimationFrame;\nvar cancel = window.cancelAnimationFrame;\n\nvar lastTime = 0;\nvar readers = [];\nvar writers = [];\nfor (var x = 0; x < vendors.length && !request; ++x) {\n  exports.request = request = window[vendors[x] + 'RequestAnimationFrame'];\n  exports.cancel = cancel = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n}\n\nif (!request) {\n  exports.request = request = function (callback) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n}\n\nif (!cancel) {\n  exports.cancel = cancel = function (id) {\n    clearTimeout(id);\n  };\n}\n\nvar read = function read(fn) {\n  readers.push(fn);\n};\n\nvar write = function write(fn) {\n  writers.push(fn);\n};\n\nvar throttle = function throttle(fn) {\n  var raf = undefined;\n\n  return function requestAnimationFrameThrottler() {\n    var args = arguments;\n    if (raf) {\n      cancel(raf);\n    }\n\n    raf = read(function requestAnimationFrameHandler() {\n      raf = false;\n      fn.apply(this, args);\n    });\n  };\n};\n\nvar loop = function loop() {\n  var read = readers;\n  readers = [];\n  read.forEach(function (t) {\n    return t();\n  });\n\n  var write = writers;\n  writers = [];\n  write.forEach(function (t) {\n    return t();\n  });\n\n  request(loop, 'loop set');\n};\n\nrequest(loop, 'loop set');\n\nexports.request = request;\nexports.cancel = cancel;\nexports.read = read;\nexports.write = write;\nexports.throttle = throttle;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./libs/fps.js\n ** module id = 3\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = {\n  eventType: undefined, // what event type will be used. undefined = autodetect\n  'document': document, // the bottom most DOM element used for \"move\" and \"end\" events\n  preventDefault: true,\n  onReady: undefined\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./iscroll.options.js\n ** module id = 4\n ** module chunks = 0\n **/","/**\n * Part, detects environment, supports, etc\n *\n */\n'use strict';\n\n/**\n * detectVendorPrefix\n * Browser vendor, used to apply CSS properties\n * @param {Object} detects - object to write detected data\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar detectVendorPrefix = function detectVendorPrefix(detects) {\n  var elementStyle = document.createElement('div').style;\n  var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'];\n  var vendor = false;\n\n  for (var i = 0, l = vendors.length; i < l; i++) {\n    if (vendors[i] + 'ransform' in elementStyle) {\n      vendor = vendors[i].substr(0, vendors[i].length - 1);\n      break;\n    }\n  }\n\n  detects.vendor = vendor;\n};\n\n/**\n * detectTransitionEnd\n * Find the transitionEnd event based on the vendor, there's no pattern so\n * we have to use a function\n * @param {Object} detects - object to write detected data\n */\nvar detectTransitionEnd = function detectTransitionEnd(detects) {\n  var types = {\n    '': 'transitionend',\n    'webkit': 'webkitTransitionEnd',\n    'Moz': 'transitionend',\n    'O': 'oTransitionEnd',\n    'ms': 'MSTransitionEnd'\n  };\n\n  detects.vendor = types[detects.vendor] || false;\n};\n\n/**\n * prefixCSSProperty\n * If needed prefix the CSS property with the vendor specific version\n * @param {string}   style - property to prefix\n * @param {Object} detects - object to write detected data\n */\nvar prefixCSSProperty = function prefixCSSProperty(style, detects) {\n  var vendor = detects.vendor;\n\n  if (!vendor) {\n    return false;\n  }\n\n  var elementStyle = document.createElement('div').style;\n  style = vendor === '' ? style : vendor + style.charAt(0).toUpperCase() + style.substr(1);\n  return style in elementStyle && style;\n};\n\n/**\n * detectPointerEvents\n * Find what kind of events supports on client\n * @param {Object} detects - object to write detected data\n */\nvar detectPointerEvents = function detectPointerEvents(detects) {\n\n  Object.assign(detects, {\n    hasPointerEvents: !!window.navigator.pointerEnabled,\n    hasMSpointerEvents: !!window.navigator.msPointerEnabled,\n    // we are going to use user agent spoofing to prevent touch events on desktop. TODO: can it be done w/o spoofing?\n    useTouchEvents: 'ontouchstart' in window && /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(window.navigator.userAgent)\n  });\n\n  detects.useMouseEvents = !detects.hasPointerEvents && !detects.hasMSpointerEvents && !detects.useTouchEvents;\n};\n\n/**\n * apply\n * Extend object with calculated client data\n * @param {object} IscrollPrototype - target object\n */\n\nexports.default = function (IscrollPrototype) {\n  IscrollPrototype.detects = {};\n  IscrollPrototype.styles = {};\n  var detects = IscrollPrototype.detects;\n  var styles = IscrollPrototype.styles;\n\n  // run detects;\n\n  detectPointerEvents(detects);\n  detectVendorPrefix(detects);\n  detectTransitionEnd(detects);\n\n  // run style prefixes\n  Object.assign(styles, {\n    transform: prefixCSSProperty('transform', detects),\n    transitionDuration: prefixCSSProperty('transitionDuration', detects)\n  });\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./iscroll.detects.js\n ** module id = 5\n ** module chunks = 0\n **/","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fps = require('../libs/fps.js');\n\nexports.default = function (IscrollInstance) {\n  var stats = document.createElement('div');\n  var oldstring = undefined,\n      newstring = undefined;\n\n  stats.style.position = 'fixed';\n  stats.style.top = 0;\n  stats.style.right = 0;\n  stats.style.padding = 10;\n  stats.style.background = 'red';\n  document.body.appendChild(stats);\n\n  function tick() {\n    newstring = JSON.stringify(IscrollInstance.state, null, 4);\n    if (oldstring !== newstring) {\n      oldstring = newstring;\n      stats.innerHTML = '<pre style=\"width:360px\">' + newstring + '</pre>';\n    }\n    (0, _fps.write)(tick);\n  }\n  (0, _fps.write)(tick);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./dev/StatePanel.js\n ** module id = 6\n ** module chunks = 0\n **/"],"sourceRoot":""}